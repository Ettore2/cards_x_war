#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>
#include <time.h>


#include "genericList.c"
#include "c_x_w_field_objects.c"
#include "c_x_w_cards.c"
#include "c_x_w_relics.c"
#include "c_x_w_potions.c"
#include "c_x_w_map_events.c"

#define ENTER_ASHII_CODE 13
#define GO_BACK_ASHII_CODE 'q'

#define COMMAND_QUIT '0'

#define STARTING_GOLD 10

int reserved_lastVal = 0;


typedef enum gameStates{
    STATE_INSTRUCTIONS_SCREEN,
    STATE_START_SCREEN,
    STATE_OPTIONS,
    STATE_CHARACTER_SELECTION,
    STATE_NAVIGATION,
    STATE_BATTLING,
    STATE_BATTLE_REWARD,
    STATE_SHOP,
    STATE_CHEST,
    STATE_ANVIL,
    STATE_REST_SITE,
    STATE_LOST,
    STATE_WON
}gameStates_e;
typedef enum spritesTypes{
    SPRITE_TYPE_GUI,
    SPRITE_TYPE_NAVIGATION,
    SPRITE_TYPE_FIEL_OBJECT,
    SPRITE_TYPE_CARD,
    SPRITE_TYPE_RELIC,
    SPRITE_TYPE_POTION
}spritesTypes_e;
typedef enum navigationFocusses{
    NAV_FOCUS_MAP,
    NAV_FOCUS_CARDS,
    NAV_FOCUS_RELICS,



    NAV_FOCUS_NULL,

    NAV_META_NUMBER_OF_OPTIONS
}navigationFocusses_e;//order is important
typedef enum mapEvents{
    
    NORMAL_ENCOUNTER, 
    ABNORMAL_ENCOUNTER,
    BOSS_ENCOUNTER,
    ANVIL,
    RANDOM_EVENT,
    REST_SITE,
    CHEST,
    SHOP
} mapEvents_e;

typedef struct player{
    fieldObject_t *character;
    genericListNode_t *relics;
    genericListNode_t *drawDeck;
    genericListNode_t *discardDeck;
    genericListNode_t *exhaustDeck;
    genericListNode_t *potions;
    int gold;
    int muves;
}
player_t;
typedef struct gameInstance{
    gameStates_e currGameState;
    player_t player;
    int currGameFieldSize;
    fieldObject_t **gameField;
    genericListNode_t *cardsPool;
    genericListNode_t *relicsPool;
    map_events_chances_t mapEventsChances;
    int difficultyLevel;
    int steps;
    map_event_t map[MAP_COLUMS][MAP_ROWS];
    int currMapPos;
    int gameSeed;
    int gameSeedUses;
    int flagChangeGameState;
    int currCardRemovalCost;

}gameInstance_t;

void destroyLastGameInstance(gameInstance_t *game){
    int i,found = 0;
    genericListNode_t *nodeTmp;

    if(game->gameField != NULL){
        for(i = game->currGameFieldSize-1; i >= 0; i++){
            if(game->gameField[i] != NULL){
                if(game->gameField[i] == game->player.character){
                    found = 1;
                }

                destroyFieldObject(game->gameField[i]);
            }
        }
        free(game->gameField);
        game->gameField == NULL;
    }
    
    if(game->player.character != NULL){
        if(!found){
            destroyFieldObject(game->player.character);
        }
        game->player.character = NULL;
    }
    
    genList_Iterate(game->cardsPool,destroyCard);
    genList_DestroyAll(&(game->cardsPool));
    
    genList_Iterate(game->relicsPool,destroyRelic);
    genList_DestroyAll(&(game->relicsPool));

    genList_Iterate(game->player.relics,destroyRelic);
    genList_DestroyAll(&(game->player.relics));
    
    genList_Iterate(game->player.drawDeck,destroyCard);
    genList_DestroyAll(&(game->player.drawDeck));
    
    genList_Iterate(game->player.discardDeck,destroyCard);
    genList_DestroyAll(&(game->player.discardDeck));
    
    genList_Iterate(game->player.exhaustDeck,destroyCard);
    genList_DestroyAll(&(game->player.exhaustDeck));
    
    genList_Iterate(game->player.potions,destroyPotion);
    genList_DestroyAll(&(game->player.potions));

}

void positionwPrintf(int x, int y){
    wprintf(L"\e[%d;%dH",y,x);
}
void setwPrintfColor(int fg, int bg){
    if(fg != -1 && bg != -1){
            wprintf(L"\e[38;5;%dm\e[48;5;%dm",fg,bg);
    }else{
        if(fg != -1){
            wprintf(L"\e[38;5;%dm",fg);
        }
        if(bg != -1){
            wprintf(L"\e[48;5;%dm",bg);
        }
    }
    
}
void setwPrintf(int x, int y,int fg, int bg){
    if(fg != -1 && bg != -1){
        wprintf(L"\e[%d;%dH\e[38;5;%dm\e[48;5;%dm",y,x,fg,bg);
    }else{
        if(fg != -1){
            wprintf(L"\e[%d;%dH\e[38;5;%dm",y,x,fg);
        }
        if(bg != -1){
            wprintf(L"\e[%d;%dH\e[48;5;%dm",y,x,bg);
        }
    }
}
void deleteCurrLine(){
    wprintf(L"\e[0K");
}

void drawGuiSprite(int x, int y, int spriteId){
    wprintf(L"\e[%d;%dH",y,x);
    switch (spriteId){
        case 0://start screen bg
            wprintf(L"\e[48;5;159m\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄\e[48;5;159m▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄▄▄▄▄\e[48;5;159m▄▄▄▄▄▄▄▄▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄▄▄▄▄▄\e[38;5;159m▄▄▄▄▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;159m▄▄▄▄▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;159m▄▄▄\e[38;5;159m▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;159m▄▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;159m▄▄▄▄▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;159m▄▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;159m▄▄▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;159m▄▄▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;159m▄▄▄▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄▄▄▄▄▄\e[1B\e[126D\e[48;5;21m\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;159m▄▄\e[38;5;159m▄▄▄▄▄▄\e[38;5;19m▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄▄\e[48;5;17m▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;0m\e[38;5;0m▄\e[48;5;21m▄\e[38;5;20m▄▄▄▄▄▄▄\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;0m\e[38;5;0m▄▄▄▄\e[48;5;20m▄▄\e[38;5;20m▄▄▄▄▄▄▄\e[48;5;21m▄▄▄▄▄▄\e[38;5;21m▄▄▄▄▄\e[38;5;20m▄▄▄▄▄▄▄\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄▄▄▄▄▄▄▄▄▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄\e[48;5;20m▄▄▄▄\e[48;5;0m▄▄▄▄\e[48;5;20m▄▄\e[38;5;20m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;21m▄▄▄▄\e[38;5;21m▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄▄▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;20m▄▄\e[38;5;20m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;20m▄▄\e[38;5;20m▄\e[38;5;19m▄▄▄▄▄\e[48;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;18m▄▄▄▄▄▄▄▄▄\e[38;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄▄▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;19m▄▄\e[38;5;19m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;18m▄▄▄▄\e[48;5;18m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;19m▄▄▄▄\e[38;5;19m▄▄▄▄▄▄\e[38;5;17m▄▄▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄\e[48;5;0m▄▄▄\e[48;5;17m▄▄\e[1B\e[126D\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;19m▄\e[38;5;19m▄▄▄▄▄\e[38;5;18m▄▄▄\e[48;5;18m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄▄▄\e[48;5;0m▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;18m▄\e[38;5;18m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄▄▄▄▄▄▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;18m▄▄\e[38;5;18m▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;17m▄▄▄▄▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄▄▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;18m▄▄\e[38;5;18m▄\e[38;5;17m▄▄▄▄\e[48;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;17m▄▄\e[38;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄▄▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;17m▄▄\e[38;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄▄▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[126D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;17m▄▄\e[38;5;17m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄▄▄▄▄▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄");
            break;
        case 1://start screen fg
            wprintf(L"\e[48;5;159m\e[38;5;0m▄\e[48;5;0m▄▄▄▄▄▄\e[48;5;159m\e[38;5;159m▄\e[38;5;0m▄\e[48;5;0m▄▄▄▄▄\e[48;5;159m▄\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄\e[48;5;159m▄\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄\e[48;5;159m▄\e[38;5;159m▄\e[38;5;0m▄\e[48;5;0m▄▄▄▄▄▄▄\e[1B\e[40D▄▄\e[48;5;159m\e[38;5;159m▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m\e[38;5;159m▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m▄▄▄▄▄▄\e[1B\e[40D\e[48;5;0m▄▄\e[48;5;159m▄▄▄▄▄\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[38;5;159m▄▄▄\e[38;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[38;5;159m▄▄▄\e[38;5;0m▄\e[48;5;159m▄\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[38;5;0m▄▄▄▄▄▄\e[48;5;0m▄▄\e[1B\e[40D\e[48;5;159m\e[38;5;159m▄\e[48;5;0m▄▄▄▄▄▄\e[48;5;159m▄\e[48;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m▄\e[48;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m▄\e[48;5;0m▄▄▄▄▄▄\e[48;5;159m▄▄\e[48;5;0m▄▄▄▄▄▄▄\e[48;5;159m▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄▄\e[38;5;159m▄▄▄\e[38;5;0m▄▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄\e[38;5;0m▄▄\e[48;5;159m▄\e[48;5;0m▄▄\e[38;5;159m▄\e[48;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄\e[48;5;0m▄▄▄\e[48;5;159m▄\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[38;5;159m▄\e[48;5;159m▄\e[48;5;0m▄\e[38;5;0m▄▄\e[48;5;159m\e[38;5;159m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m\e[38;5;159m▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[38;5;0m▄\e[48;5;0m▄▄▄▄▄\e[48;5;159m▄\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄\e[48;5;159m▄\e[38;5;159m▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[38;5;0m▄\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m\e[38;5;159m▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄\e[38;5;159m▄\e[38;5;0m▄▄▄\e[48;5;159m\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[38;5;159m▄▄▄\e[38;5;0m▄▄\e[48;5;159m\e[38;5;159m▄\e[48;5;0m\e[38;5;0m▄▄\e[38;5;159m▄▄▄\e[38;5;0m▄\e[48;5;159m▄\e[38;5;159m▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄\e[48;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m▄\e[48;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m▄\e[48;5;0m▄▄\e[48;5;159m▄▄▄\e[48;5;0m▄▄\e[48;5;159m▄▄▄▄▄▄▄▄▄");
            break;
        case 2://black selection ring
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[30D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄");
            break;
        case 3://gold selection ring
            wprintf(L"\e[48;5;0m\e[38;5;220m▄\e[48;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄\e[1B\e[30D\e[48;5;220m▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄\e[1B\e[30D\e[38;5;0m▄\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄");break;
            break;
        case 4://red selection ring
            wprintf(L"\e[48;5;0m\e[38;5;1m▄\e[48;5;1m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄\e[1B\e[30D\e[48;5;1m▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;1m▄▄\e[1B\e[30D\e[38;5;0m▄\e[38;5;1m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄");
            break;
        case 5://blue selection ring
            wprintf(L"\e[48;5;0m\e[38;5;4m▄\e[48;5;4m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄\e[1B\e[30D\e[48;5;4m▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;4m\e[38;5;4m▄▄\e[1B\e[30D\e[38;5;0m▄\e[38;5;4m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄");
            break;
        case 6://green selection ring
            wprintf(L"\e[48;5;0m\e[38;5;10m▄\e[48;5;10m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄\e[1B\e[30D\e[48;5;10m▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D▄▄\e[48;5;231m\e[38;5;231m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;10m\e[38;5;10m▄▄\e[1B\e[30D\e[38;5;0m▄\e[38;5;10m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄");break;
            break;
        case 7://coin big
            wprintf(L"\e[48;5;0m\e[38;5;0m▄\e[38;5;3m▄\e[48;5;3m\e[38;5;226m▄\e[48;5;220m▄\e[38;5;227m▄\e[48;5;221m▄\e[48;5;0m\e[38;5;221m▄\e[38;5;0m▄\e[1B\e[8D\e[48;5;3m\e[38;5;3m▄\e[48;5;226m\e[38;5;226m▄▄\e[38;5;3m▄▄\e[48;5;227m\e[38;5;226m▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[8D\e[48;5;3m\e[38;5;3m▄\e[48;5;226m\e[38;5;226m▄▄\e[48;5;3m▄▄\e[48;5;226m▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[8D\e[48;5;0m\e[38;5;0m▄\e[48;5;3m▄\e[48;5;226m\e[38;5;3m▄▄▄▄\e[48;5;3m\e[38;5;0m▄\e[48;5;0m▄");
            break;
        case 8://coin small
            wprintf(L"\e[48;5;0m\e[38;5;0m▄\e[38;5;3m▄\e[48;5;3m\e[38;5;226m▄\e[48;5;220m▄\e[38;5;227m▄\e[48;5;221m▄\e[48;5;0m\e[38;5;221m▄\e[38;5;0m▄\e[1B\e[8D\e[48;5;3m\e[38;5;3m▄\e[48;5;226m\e[38;5;226m▄▄\e[38;5;3m▄▄\e[48;5;227m\e[38;5;226m▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[8D\e[48;5;3m\e[38;5;3m▄\e[48;5;226m\e[38;5;226m▄▄\e[48;5;3m▄▄\e[48;5;226m▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[8D\e[48;5;0m\e[38;5;0m▄\e[48;5;3m▄\e[48;5;226m\e[38;5;3m▄▄▄▄\e[48;5;3m\e[38;5;0m▄\e[48;5;0m▄");
            break;
        case 9://chest closed
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄\e[38;5;124m▄\e[48;5;124m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄\e[38;5;0m▄\e[1B\e[40D\e[48;5;124m\e[38;5;88m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D\e[48;5;88m▄▄▄▄\e[38;5;16m▄\e[38;5;88m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D\e[38;5;52m▄▄▄\e[38;5;16m▄\e[48;5;16m\e[38;5;52m▄\e[48;5;88m▄▄▄▄▄\e[38;5;16m▄\e[48;5;16m▄▄\e[48;5;88m▄\e[38;5;52m▄▄▄▄▄\e[48;5;240m\e[38;5;239m▄\e[38;5;238m▄▄\e[38;5;239m▄\e[48;5;88m\e[38;5;52m▄▄▄▄▄▄▄▄\e[48;5;16m▄▄▄\e[48;5;88m▄\e[38;5;16m▄▄\e[38;5;52m▄▄▄\e[1B\e[40D\e[48;5;52m▄▄▄▄▄▄▄▄▄▄▄\e[48;5;16m▄\e[48;5;52m▄▄▄▄▄▄▄\e[48;5;239m▄\e[48;5;238m\e[38;5;239m▄▄\e[48;5;239m\e[38;5;52m▄\e[48;5;52m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄"); 
            break;
        case 10://chest open
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄\e[38;5;124m▄▄▄\e[38;5;0m▄\e[38;5;124m▄▄▄▄\e[38;5;0m▄▄\e[38;5;124m▄▄▄▄\e[48;5;239m▄▄▄▄\e[48;5;0m▄▄▄\e[38;5;0m▄▄▄\e[38;5;124m▄▄▄▄▄▄\e[38;5;0m▄▄▄▄▄\e[1B\e[40D▄▄\e[38;5;124m▄\e[48;5;124m▄▄▄▄\e[38;5;88m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;124m▄▄▄▄\e[48;5;0m▄\e[38;5;0m▄▄\e[1B\e[40D\e[38;5;124m▄\e[48;5;124m▄▄▄\e[38;5;88m▄\e[48;5;88m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;124m▄\e[38;5;124m▄▄▄\e[48;5;0m▄\e[1B\e[40D\e[48;5;124m▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;124m\e[38;5;124m▄▄▄\e[1B\e[40D▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;124m\e[38;5;124m▄▄▄\e[1B\e[40D▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;124m\e[38;5;124m▄▄▄\e[1B\e[40D\e[38;5;52m▄▄▄\e[48;5;88m\e[38;5;16m▄\e[38;5;52m▄▄▄▄▄▄\e[38;5;16m▄▄▄▄\e[38;5;52m▄▄▄▄▄▄\e[38;5;240m▄▄\e[38;5;52m▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;16m▄▄\e[48;5;124m\e[38;5;52m▄▄▄\e[1B\e[40D\e[48;5;52m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;240m▄▄\e[48;5;52m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[40D\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄");
            break;
        case 11://shop card removal
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄\e[38;5;8m▄\e[48;5;8m▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄\e[38;5;0m▄▄▄\e[1B\e[20D▄▄\e[48;5;8m\e[38;5;8m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[20D▄\e[48;5;8m\e[38;5;8m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄\e[1B\e[20D\e[48;5;8m\e[38;5;8m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄\e[38;5;196m▄▄\e[38;5;8m▄▄▄▄▄▄▄▄▄▄\e[38;5;196m▄▄\e[38;5;8m▄▄▄\e[1B\e[20D▄▄▄\e[48;5;196m▄\e[38;5;196m▄▄\e[48;5;8m▄\e[38;5;8m▄▄▄▄▄▄\e[38;5;196m▄\e[48;5;196m▄▄\e[38;5;8m▄\e[48;5;8m▄▄▄\e[1B\e[20D▄▄▄▄▄\e[48;5;196m▄\e[38;5;196m▄▄\e[48;5;8m▄\e[38;5;8m▄▄\e[38;5;196m▄\e[48;5;196m▄▄\e[38;5;8m▄\e[48;5;8m▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄\e[48;5;196m▄\e[38;5;196m▄▄▄▄\e[38;5;8m▄\e[48;5;8m▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄\e[38;5;196m▄\e[48;5;196m▄▄▄▄\e[48;5;8m▄\e[38;5;8m▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄\e[38;5;196m▄\e[48;5;196m▄▄\e[38;5;8m▄\e[48;5;8m▄▄\e[48;5;196m▄\e[38;5;196m▄▄\e[48;5;8m▄\e[38;5;8m▄▄▄▄▄\e[1B\e[20D▄▄▄\e[38;5;196m▄\e[48;5;196m▄▄\e[38;5;8m▄\e[48;5;8m▄▄▄▄▄▄\e[48;5;196m▄\e[38;5;196m▄▄\e[48;5;8m▄\e[38;5;8m▄▄▄\e[1B\e[20D▄▄▄\e[48;5;196m▄▄\e[48;5;8m▄▄▄▄▄▄▄▄▄▄\e[48;5;196m▄▄\e[48;5;8m▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D\e[48;5;0m\e[38;5;0m▄\e[48;5;8m\e[38;5;8m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄\e[1B\e[20D▄▄\e[48;5;8m\e[38;5;8m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[20D▄▄▄\e[48;5;8m▄\e[38;5;8m▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄\e[48;5;0m▄▄▄");
            break;
        case 12://selected card bg
            wprintf(L"\e[48;5;0m\e[38;5;0m▄\e[38;5;220m▄\e[48;5;220m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;220m▄\e[38;5;0m▄\e[1B\e[24D\e[48;5;220m\e[38;5;220m▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[24D\e[48;5;0m\e[38;5;0m▄\e[48;5;220m▄\e[48;5;0m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;0m▄\e[48;5;0m▄");
            break;
        case 13://non-selected card bg
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄");
            break;
        case 14://selected relic bg
            wprintf(L"\e[48;5;0m\e[38;5;220m▄\e[48;5;220m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;220m▄\e[1B\e[20D\e[48;5;220m▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[20D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[20D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[20D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[20D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[20D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[20D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[20D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;220m▄\e[1B\e[20D\e[38;5;0m▄\e[48;5;0m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;220m\e[38;5;0m▄");
            break;
        case 15://non-selected relic bg
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄");
            break;
        case 16://delete card
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[20D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄");
            break;
        case 17: //delete relic
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[16D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[16D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[16D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[16D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[16D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[16D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[16D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄");
            break;
        case 18: //shop pixel arx
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄\e[38;5;1m▄▄\e[48;5;8m\e[38;5;2m▄▄\e[48;5;0m\e[38;5;1m▄▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄\e[38;5;1m▄▄\e[48;5;1m▄\e[38;5;2m▄▄\e[48;5;2m\e[38;5;1m▄\e[38;5;2m▄▄\e[38;5;1m▄\e[48;5;1m\e[38;5;2m▄▄\e[38;5;1m▄\e[48;5;0m▄▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄\e[38;5;1m▄▄\e[48;5;1m▄\e[38;5;2m▄▄\e[48;5;2m▄\e[38;5;1m▄\e[48;5;1m▄▄\e[38;5;2m▄\e[48;5;2m▄▄\e[48;5;1m▄\e[38;5;1m▄▄\e[48;5;2m▄\e[38;5;2m▄\e[48;5;1m▄▄\e[38;5;1m▄\e[48;5;0m▄▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄\e[48;5;1m▄▄\e[38;5;2m▄\e[48;5;2m▄▄\e[38;5;1m▄\e[48;5;1m▄▄▄▄\e[38;5;2m▄\e[48;5;2m▄▄▄▄\e[48;5;1m▄\e[38;5;1m▄▄▄▄\e[48;5;2m▄\e[38;5;2m▄▄\e[48;5;1m▄\e[38;5;0m▄▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄\e[48;5;1m▄▄▄▄▄\e[48;5;2m\e[38;5;2m▄▄▄▄▄▄\e[48;5;1m\e[38;5;0m▄▄▄▄▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;250m\e[38;5;250m▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;250m\e[38;5;250m▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;250m\e[38;5;250m▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;252m\e[38;5;252m▄\e[48;5;250m▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;252m\e[38;5;252m▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;252m\e[38;5;252m▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;252m\e[38;5;252m▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;252m\e[38;5;252m▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;252m\e[38;5;252m▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[51D▄▄▄▄\e[38;5;160m▄\e[48;5;160m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;124m▄\e[48;5;0m\e[38;5;0m▄\e[1B\e[51D▄▄\e[38;5;160m▄\e[48;5;160m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;124m▄\e[48;5;124m\e[38;5;88m▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[51D▄\e[48;5;160m\e[38;5;124m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;124m\e[38;5;88m▄\e[48;5;88m▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[51D▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[51D▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄\e[48;5;22m\e[38;5;22m▄▄▄▄▄\e[48;5;52m\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄▄▄▄▄\e[48;5;52m\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄▄\e[48;5;22m\e[38;5;22m▄▄▄▄▄\e[48;5;52m\e[38;5;52m▄▄\e[38;5;3m▄\e[48;5;3m\e[38;5;220m▄▄▄▄\e[48;5;52m\e[38;5;3m▄\e[38;5;52m▄▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[51D▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m▄\e[38;5;52m▄▄▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄\e[38;5;3m▄▄\e[38;5;220m▄\e[48;5;3m\e[38;5;3m▄\e[48;5;52m\e[38;5;52m▄▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[51D▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄▄\e[48;5;22m▄\e[38;5;22m▄▄\e[48;5;52m▄\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄▄▄▄▄\e[48;5;52m\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄▄\e[48;5;22m\e[38;5;22m▄▄▄▄\e[48;5;52m\e[38;5;52m▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄\e[48;5;3m\e[38;5;3m▄▄\e[48;5;220m\e[38;5;220m▄\e[48;5;3m\e[38;5;3m▄\e[48;5;52m\e[38;5;52m▄▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[51D▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄\e[38;5;22m▄▄▄\e[48;5;22m▄▄\e[48;5;52m\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m▄▄▄\e[38;5;52m▄▄\e[48;5;22m\e[38;5;22m▄▄\e[48;5;52m▄▄▄\e[38;5;52m▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;52m\e[38;5;52m▄▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[51D▄\e[38;5;241m▄\e[48;5;52m\e[38;5;52m▄▄▄▄\e[48;5;22m▄▄▄▄▄\e[48;5;52m▄▄\e[48;5;22m▄▄\e[48;5;52m▄▄\e[48;5;22m▄▄\e[48;5;52m▄▄\e[48;5;22m▄▄▄▄▄\e[48;5;52m▄▄\e[48;5;22m▄▄▄▄▄\e[48;5;52m▄▄▄\e[48;5;3m▄▄▄▄\e[48;5;52m▄▄▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄\e[1B\e[51D\e[48;5;241m\e[38;5;241m▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;88m\e[38;5;88m▄▄▄\e[38;5;241m▄\e[48;5;241m▄\e[48;5;0m▄\e[1B\e[51D\e[48;5;241m▄▄\e[48;5;52m\e[38;5;52m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;88m\e[38;5;88m▄\e[38;5;241m▄\e[48;5;241m▄▄▄▄\e[1B\e[51D\e[38;5;0m▄\e[38;5;241m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄");
            break;
        case 19://anvil card to upgrade
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄\e[38;5;3m▄\e[48;5;3m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;3m▄\e[38;5;0m▄▄\e[1B\e[20D▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;0m\e[38;5;0m▄\e[1B\e[20D\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄\e[38;5;3m▄\e[48;5;3m▄▄\e[48;5;220m▄\e[38;5;220m▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄\e[38;5;3m▄\e[48;5;3m▄▄▄▄▄▄\e[48;5;220m▄\e[38;5;220m▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D\e[48;5;0m\e[38;5;0m▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;0m\e[38;5;0m▄\e[1B\e[20D▄▄\e[48;5;3m▄\e[48;5;220m\e[38;5;3m▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;0m▄\e[48;5;0m▄▄");
            break;
        case 20://anvil card to destroy
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄\e[38;5;3m▄\e[48;5;3m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;3m▄\e[38;5;0m▄▄\e[1B\e[20D▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;0m\e[38;5;0m▄\e[1B\e[20D\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄\e[38;5;3m▄▄\e[38;5;220m▄▄▄▄\e[38;5;3m▄▄\e[38;5;220m▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄\e[48;5;3m▄\e[38;5;3m▄▄\e[48;5;220m▄▄\e[48;5;3m▄▄\e[38;5;220m▄\e[48;5;220m▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄▄▄▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄\e[38;5;3m▄\e[48;5;3m▄▄\e[38;5;220m▄▄\e[38;5;3m▄▄\e[48;5;220m▄\e[38;5;220m▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄\e[48;5;3m▄▄\e[48;5;220m▄▄▄▄\e[48;5;3m▄▄\e[48;5;220m▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D\e[48;5;0m\e[38;5;0m▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;0m\e[38;5;0m▄\e[1B\e[20D▄▄\e[48;5;3m▄\e[48;5;220m\e[38;5;3m▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;0m▄\e[48;5;0m▄▄");
            break;
        case 21://anvil card result
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄\e[38;5;3m▄\e[48;5;3m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;3m▄\e[38;5;0m▄▄\e[1B\e[20D▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;0m\e[38;5;0m▄\e[1B\e[20D\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄\e[38;5;3m▄▄\e[48;5;3m\e[38;5;220m▄▄▄▄\e[48;5;220m\e[38;5;3m▄▄\e[38;5;220m▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄\e[38;5;3m▄\e[48;5;3m\e[38;5;220m▄\e[48;5;220m▄▄▄▄▄▄\e[48;5;3m▄\e[48;5;220m\e[38;5;3m▄\e[38;5;220m▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄\e[48;5;3m\e[38;5;3m▄▄\e[48;5;220m\e[38;5;220m▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄\e[48;5;3m▄\e[48;5;220m\e[38;5;3m▄\e[38;5;220m▄▄▄▄▄▄\e[38;5;3m▄\e[48;5;3m\e[38;5;220m▄\e[48;5;220m▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄\e[48;5;3m▄▄\e[48;5;220m\e[38;5;3m▄▄▄▄\e[48;5;3m\e[38;5;220m▄▄\e[48;5;220m▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[20D\e[48;5;0m\e[38;5;0m▄\e[48;5;3m\e[38;5;3m▄\e[48;5;220m\e[38;5;220m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[48;5;0m\e[38;5;0m▄\e[1B\e[20D▄▄\e[48;5;3m▄\e[48;5;220m\e[38;5;3m▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;0m▄\e[48;5;0m▄▄");
            break;
        case 22://anvil card selection
            wprintf(L"\e[48;5;0m\e[38;5;3m▄\e[48;5;3m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;3m▄\e[1B\e[24D\e[48;5;3m▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;3m▄\e[1B\e[24D\e[38;5;0m▄\e[48;5;0m\e[38;5;3m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;3m\e[38;5;0m▄");
            break;
        case 23://anvil card selection deletion
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄{}▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[24D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄");
            break;
        case 24: //anvil pixel arx
            wprintf(L"\e[48;5;246m\e[38;5;246m▄▄▄▄\e[38;5;243m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;246m▄▄\e[38;5;0m▄\e[1B\e[48D\e[38;5;243m▄\e[48;5;243m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;246m▄\e[48;5;246m▄\e[38;5;0m▄\e[48;5;0m▄▄\e[1B\e[48D\e[48;5;243m\e[38;5;243m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;246m▄\e[48;5;246m▄\e[38;5;0m▄\e[48;5;0m▄▄▄▄\e[1B\e[48D\e[48;5;243m\e[38;5;243m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;246m▄\e[48;5;246m▄\e[38;5;0m▄\e[48;5;0m▄▄▄▄▄▄\e[1B\e[48D\e[48;5;243m▄▄\e[38;5;243m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;246m▄\e[48;5;246m▄\e[38;5;0m▄\e[48;5;0m▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄\e[48;5;243m▄▄▄▄▄▄▄▄▄▄\e[38;5;241m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄▄▄▄▄▄\e[48;5;246m▄▄▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;242m\e[38;5;242m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;242m\e[38;5;242m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;242m\e[38;5;242m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;242m\e[38;5;242m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;242m\e[38;5;242m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;242m▄\e[48;5;242m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄▄▄▄\e[38;5;244m▄▄▄▄▄\e[48;5;243m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄▄▄▄▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄▄\e[38;5;244m▄\e[48;5;244m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄▄\e[48;5;244m\e[38;5;244m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄\e[1B\e[48D▄▄▄\e[48;5;245m\e[38;5;245m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄");
            break;
        case 25: //rest site pixel arx
            wprintf(L"\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m▄\e[48;5;0m▄\e[38;5;1m▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄▄\e[38;5;1m▄\e[38;5;0m▄▄▄\e[48;5;1m▄\e[48;5;0m▄▄\e[38;5;1m▄\e[38;5;0m▄▄▄▄\e[38;5;1m▄\e[38;5;0m▄\e[38;5;1m▄\e[38;5;0m▄▄\e[48;5;1m▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;1m▄\e[38;5;0m▄▄▄\e[38;5;1m▄\e[48;5;196m\e[38;5;196m▄\e[48;5;0m\e[38;5;0m▄▄▄▄\e[48;5;196m\e[38;5;196m▄\e[48;5;0m\e[38;5;0m▄▄▄\e[38;5;1m▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;196m\e[38;5;196m▄\e[48;5;0m\e[38;5;1m▄\e[38;5;0m▄▄\e[48;5;196m\e[38;5;196m▄▄\e[48;5;1m\e[38;5;0m▄\e[48;5;0m▄\e[38;5;1m▄\e[38;5;0m▄\e[48;5;196m\e[38;5;196m▄\e[48;5;1m▄\e[48;5;0m\e[38;5;0m▄▄\e[48;5;196m\e[38;5;196m▄\e[48;5;1m\e[38;5;0m▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄\e[48;5;1m▄\e[48;5;0m▄\e[38;5;196m▄\e[48;5;196m▄▄\e[48;5;0m\e[38;5;1m▄\e[38;5;0m▄\e[48;5;196m\e[38;5;196m▄▄\e[48;5;1m▄\e[48;5;0m\e[38;5;0m▄\e[38;5;196m▄\e[38;5;0m▄\e[48;5;196m\e[38;5;196m▄▄\e[48;5;0m\e[38;5;0m▄\e[48;5;1m\e[38;5;196m▄\e[48;5;196m▄\e[48;5;0m\e[38;5;1m▄\e[38;5;0m▄\e[48;5;1m▄\e[48;5;0m▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m\e[38;5;196m▄\e[48;5;196m▄▄▄▄\e[48;5;0m▄\e[48;5;196m▄▄▄\e[48;5;0m\e[38;5;0m▄\e[48;5;196m\e[38;5;196m▄\e[48;5;0m▄\e[48;5;1m▄\e[48;5;196m▄\e[48;5;0m▄\e[48;5;196m▄▄▄\e[48;5;0m▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄▄\e[48;5;196m\e[38;5;1m▄\e[38;5;196m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;1m▄\e[48;5;0m▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄▄\e[48;5;196m\e[38;5;196m▄▄▄▄▄▄▄▄▄\e[38;5;202m▄\e[38;5;196m▄▄\e[48;5;202m\e[38;5;202m▄\e[48;5;196m\e[38;5;196m▄▄▄▄▄▄\e[38;5;1m▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄\e[38;5;196m▄\e[48;5;196m▄▄▄▄▄\e[38;5;202m▄\e[38;5;196m▄▄\e[38;5;202m▄\e[48;5;202m▄\e[48;5;196m\e[38;5;196m▄▄\e[48;5;202m\e[38;5;202m▄\e[48;5;196m▄\e[38;5;196m▄\e[48;5;202m\e[38;5;202m▄\e[48;5;196m\e[38;5;196m▄▄▄▄\e[48;5;0m▄\e[38;5;0m▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄\e[48;5;196m\e[38;5;196m▄▄▄▄▄\e[38;5;202m▄\e[48;5;202m▄▄\e[48;5;196m\e[38;5;196m▄\e[48;5;202m\e[38;5;202m▄▄\e[48;5;196m▄\e[48;5;202m▄▄▄\e[48;5;196m\e[38;5;196m▄\e[48;5;202m\e[38;5;202m▄▄\e[48;5;196m\e[38;5;196m▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄\e[48;5;196m\e[38;5;196m▄▄▄▄\e[38;5;202m▄\e[48;5;202m▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;196m\e[38;5;196m▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄\e[48;5;196m\e[38;5;196m▄▄▄▄\e[48;5;202m\e[38;5;202m▄▄\e[38;5;227m▄▄▄▄▄▄▄▄▄▄▄\e[38;5;202m▄▄\e[48;5;196m\e[38;5;196m▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄\e[48;5;196m\e[38;5;196m▄▄▄▄\e[48;5;202m▄\e[48;5;227m\e[38;5;202m▄\e[38;5;227m▄▄▄▄▄▄▄▄▄▄▄\e[38;5;202m▄\e[48;5;202m\e[38;5;196m▄\e[48;5;196m▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄▄\e[48;5;196m\e[38;5;196m▄▄▄▄▄\e[48;5;202m▄▄▄▄▄▄▄▄▄▄▄\e[48;5;196m▄▄▄▄\e[48;5;0m\e[38;5;0m▄▄▄▄▄▄▄▄▄▄▄\e[1B\e[42D\e[48;5;88m\e[38;5;88m▄▄▄▄▄▄▄\e[48;5;52m▄▄▄▄▄\e[48;5;234m\e[38;5;52m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[48;5;52m\e[38;5;88m▄▄▄▄▄\e[48;5;88m▄▄▄▄▄▄▄\e[1B\e[42D▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄");
            break;
        case 26: //battle tile floor normal
            wprintf(L"\e[48;5;240m\e[38;5;0m▄\e[38;5;240m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄");
            break;
        case 27: //battle tile floor 1dmg
            wprintf(L"\e[48;5;240m\e[38;5;0m▄\e[38;5;240m▄▄▄▄▄▄▄▄▄\e[48;5;124m▄\e[38;5;124m▄▄▄▄\e[38;5;240m▄\e[48;5;240m▄▄▄▄▄▄▄▄▄\e[38;5;0m▄");
            break;
        case 28: //battle tile floor 2dmg
            wprintf(L"\e[48;5;240m\e[38;5;0m▄\e[38;5;240m▄▄▄▄▄▄\e[48;5;124m▄\e[38;5;124m▄▄▄▄▄▄▄▄▄▄\e[38;5;240m▄\e[48;5;240m▄▄▄▄▄▄\e[38;5;0m▄");
            break;
        case 29: //battle tile floor 3dmg
            wprintf(L"\e[48;5;240m\e[38;5;0m▄\e[38;5;240m▄▄▄\e[48;5;124m▄\e[38;5;124m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;240m▄\e[48;5;240m▄▄▄\e[38;5;0m▄");
            break;
        case 30: //battle tile floor more than 3
            wprintf(L"\e[48;5;124m\e[38;5;0m▄\e[38;5;124m▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄\e[38;5;0m▄");
            break;
        case 31: //emeny attack Indicator
            wprintf(L"\e[48;5;160m  \e[2D\e[1B  \e[2D\e[2B  ");
            break;
    }
    
}
void drawSprite(int x, int y,int spriteType, int spriteId){
    positionwPrintf(x,y);
    switch (spriteType)
    {
        case SPRITE_TYPE_GUI:
            drawGuiSprite(x,y,spriteId);
            break;
        case SPRITE_TYPE_NAVIGATION:
            drawNavigationSprite(x,y,spriteId);
            break;
        case SPRITE_TYPE_FIEL_OBJECT:
            drawFieldObjectSprite(x,y,spriteId);
            break;
        case SPRITE_TYPE_CARD:
            drawCardSprite(x,y,spriteId);
            break;
        case SPRITE_TYPE_RELIC:
            drawRelicSprite(x,y,spriteId);
            break;
        case SPRITE_TYPE_POTION:
            break;
    }
    
}
void drawRect(int x, int y, int color, int w, int h){
    int i;
    char s[w+1];

    for(i = 0; i < w; i++){
        s[i] = ' ';
    }
    s[w] = '\n';
    
    wprintf(L"\e[38;5;%dm\e[48;5;%dm\e[%d;%dH",color,color,y,x);
    for(i = 0; i < h; i++){
        wprintf(L"\e[%d;%dH%Ls",y+i,x,s);
    }


}

void playCard(card_t *card, gameInstance_t *game){

    /*
    switch (card->id)
    {
        case CARD_FIGHTER_MOVE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"gain %d move",values[0]);
            break;
        case CARD_FIGHTER_PUNCH:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg fw",values[0]);
            break;
        case CARD_FIGHTER_THROW:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"throw an enemy fw");
            break;
        case CARD_FIGHTER_PUSH:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"push an enemy fw");
            break;
        case CARD_FIGHTER_SPINING_PUNCH:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg fw and bw",values[0]);
            break;
        case CARD_FIGHTER_SPEAR_POKE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg 1 cell fw and %d dmg 2 cells fw",values[0],values[0]*2);
            break;
        case CARD_FIGHTER_WAKEUP_ATTACK:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"turn and deal %d dmg fw",values[0]);
            break;
        case CARD_FIGHTER_KICK:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"move fw, deal %d dmg fw, push the enemy fw",values[0]);
            break;
        case CARD_FIGHTER_MANTRA:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"gain %d move and %d mana, block",values[0],values[1]);
            break;
        case CARD_FIGHTER_RETRIVE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"move bw %d",values[0]);
            break;
        case CARD_FIGHTER_ETERNAL_KATANA:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg fw, discard a random card instead of this one",values[0]);
            break;
        case CARD_FIGHTER_SCYTHE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg fw and %d dmg bw",values[0],values[0]*2);
            break;
        case CARD_FIGHTER_SPECIAL_PUNCH:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"fw remove the targhet shield, deal %d dmg fw",values[0]);
            break;
        case CARD_FIGHTER_SCREAM:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"%d dmg to all, gain %d stress",values[0],values[1]);
            break;
        case CARD_FIGHTER_COOL_OFF:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"lose %d stress and strength, gain %d mana",values[0],values[1]);
            break;
        case CARD_FIGHTER_BLOODSHOOT:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"gain %d strength, %d stress, %d mana, copy %d",values[0],values[1],values[2],values[3]);
            break;
        case CARD_FIGHTER_BONE_CUTTER:
            cardTmp = createCard(values[3]);
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg fw or bw, add %d bleeding, add %d %s tired to your discard pile",values[0],values[1],values[2],cardTmp->name);
            destroyCard(cardTmp);
            break;
        case CARD_FIGHTER_BLACK_HEART:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"gain %d mana and stress",values[0]);
            break;
        case CARD_FIGHTER_SURROUNDED:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"gain %d mana and stress tor every enemy on the field",values[0]);
            break;
        case CARD_FIGHTER_MEDITATE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"lose %d stress, gain %d mana",values[0],values[1]);
            break;
        case CARD_FIGHTER_CURSED_SWORD:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"del %d dmg, increase the dmg by %d every time you play it this combat, take %d dmg if in hand at the end or the turn",values[3],values[0],values[2]);
            break;
        case CARD_ARCHER_MOVE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"gain %d move and %d mana",values[0],values[1]);
            break;
        case CARD_ARCHER_STAB_ATTACK:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"move %d fw, deal %d dmg fw",values[1],values[0]);
            break;
        case CARD_ARCHER_ARROW:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"shoot fw an arrow that deal %d dmg",values[0]);
            break;
        case CARD_ARCHER_LEAP:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"jump %d fw",values[0]);
            break;
        case CARD_ARCHER_TO_SAFETY:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"dash bw");
            break;
        case CARD_ARCHER_WIND_DANCE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"gain %d move. courege: gain %d move",values[0],values[0]);
            break;
        case CARD_ARCHER_HARPOON:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"fw grab an enemy and pull it to you");
            break;
        case CARD_ARCHER_WIND_BLADE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"%d dmg fw, if it damages gain 1 move",values[0],values[0]);
            break;
        case CARD_ARCHER_CROSSBOW:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"shoot fw an arrow that deal %d dmg, transform in crossbow reload",values[0]);
            break;
        case CARD_ARCHER_CROSSBOW_RELOAD:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"transform into crossbow");
            break;
        case CARD_ARCHER_ACROBATIC_SHOT:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"move fw, shoot a %d dmg arrw bw",values[0]);
            break;
        case CARD_THIEF_MOVE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"move fw, gain %d move",values[0]);
            break;
        case CARD_THIEF_BACKSTAB:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg bw",values[0]);
            break;
        case CARD_THIEF_SPIN:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"turn, gain %d move",values[0]);
            break;
        case CARD_THIEF_DASH:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"dash bw, deal %d dmg bw",values[0]);
            break;
        case CARD_THIEF_JOLLY_CARD:
            cardTmp = createCard(values[0]);
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"copy the effect of the last played card %Ls",cardTmp->id == -1 ? L"" : cardTmp->name);
            destroyCard(cardTmp);
            break;
        case CARD_THIEF_SMOKE_BOMB:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"teleport bw behind the first enemy");
            break;
        case CARD_THIEF_DAGGHER:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"throw a %d dmg daggher fw",values[0]);
            break;
        case CARD_THIEF_SNEEK:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"gain %d move, gain %d move if in your hand at the end of theturn",values[0],values[0]);
            break;
        case CARD_THIEF_CURVED_BLADE:
            cardTmp = createCard(values[1]);
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg fw, add a %Ls to your discard pile",values[0],cardTmp->name);
            destroyCard(cardTmp);
            break;
        case CARD_THIEF_DISTRACTION:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"change all enemies intents to wait");
            break;
        case CARD_THIEF_ENRAGE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"lose all move, gains %d times the ammount in streangth",values[0]);
            break;
        case CARD_THIEF_FLEE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"gain %d move for every enemy on the field, gain a shield",values[0]);
            break;
        case CARD_THIEF_CONFUSION:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"turn all, gain %d mana",values[1]);
            break;
        case CARD_THIEF_FAST_SLASH:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg fw +%d dmg for every move consumed this turn",values[1],values[0]);
            break;
        case CARD_THIEF_SMOKE_GRANADE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"set an emey action to wait");
            break;
        case CARD_THIEF_SERRATED_BLADE:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"deal %d dmg fw to an enemy, give him %d bleeding",values[1],values[0]);
            break;
        case CARD_CURSE_TIRED:
            swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L"do nothing");
            break;

        if(card->exhaust)swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L". exhaust");
        if(card->nonPermanent)swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L". temporary");
        if(card->fragial)swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L". fragial");
        if(card->retain)swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L". retain");
        if(card->giveOvercharge)swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L". gain overcharge");
        if(card->blockTheSlot)swprintf(str,CARD_DESCRIPTION_MAX_LENGTH,L". block the slot");
    }

*/

    if(card->blockTheSlot){

    }
    if(card->exhaust){

    }
    if(card->giveOvercharge){

    }
}

int legalRand(gameInstance_t *game){
        game->gameSeedUses++;
        return rand();
}
int normalRand(){
    int val = time(NULL)+3*reserved_lastVal;
    if(val < 0){
        val = -val;
    }
    reserved_lastVal = val;
    return val;
}
void furtherCreateMap(gameInstance_t *game){
    int tmp;
    int x,y;
    int creatorVector[MAP_ROWS];

    for(y = 0; y < MAP_ROWS; y++){
        creatorVector[y] = 0;
    }
    for(y = 0; y < MAP_ROWS; y++){
        if(game->map[MAP_COLUMS-1][y].id != EVENT_EMPTY){
            tmp = legalRand(game)%3+y-1;
            while (!(tmp >= 0 && tmp < MAP_ROWS)){
                tmp = legalRand(game)%3+y-1;
            }
            creatorVector[tmp] = 1;
            
            tmp = legalRand(game);
            if(tmp%100 < MAP_NODE_2_PATHS_CHANCE){
                tmp = tmp%3+y-1;
                while (!(tmp >= 0 && tmp < MAP_ROWS)){
                    tmp = legalRand(game)%3+y-1;
                }
                creatorVector[tmp] = 1;
            }
        }
    }

    for(y = 0; y < MAP_ROWS; y++){
        for(x = 0; x < MAP_COLUMS-1; x++){
            game->map[x][y] = game->map[x+1][y];
        }
        if(creatorVector[y]){
            initializeRandomMapEvent(&(game->mapEventsChances), &game->map[MAP_COLUMS-1][y], legalRand(game));
        }else{
            initializeSpecificMapEvent(&game->map[MAP_COLUMS-1][y],EVENT_EMPTY);
        }
    }

}


void routineCharacterSelection(char *ptrCommand, gameInstance_t *game){
    const int SHOWN_HEROES = 7;
    const int CHARACTERS_X_OFFSET = 4, CHARACTERS_Y_OFFSET = 4,
    INSTRUCTIONS_Y_OFFSET = (CHARACTERS_Y_OFFSET+FIELD_CELL_HEIGHT+2)+1,STATS_Y_OFFSET = INSTRUCTIONS_Y_OFFSET + 2;
    int i,j;
    int needRedraw = 1;
    fieldObject_t *(heroes[NUMBER_OF_PLAYABLE_CHARACTERS]);//never lose the malloc return!!!!!! (otherwise you free a non dinamically allocated cell)
    int currHeroOffset = 0;
    fieldObject_t *selectedHero = NULL;
    relic_t * selectedHeroRelic = NULL;
    genericListNode_t * selectedHeroDeck = NULL;
    genericListNode_t * cardTmp = NULL;

    for(i = 0; i < NUMBER_OF_PLAYABLE_CHARACTERS; i++){
        heroes[i] = createFieldObject(PLAYABLE_CHARACTERS_IDS[i]);
    }
    
    setwPrintfColor(0,0);
    system("cls");

    drawGuiSprite(CHARACTERS_X_OFFSET-2,CHARACTERS_Y_OFFSET-1,3);//draw golden ring

    setwPrintfColor(15,0);
    positionwPrintf(1,INSTRUCTIONS_Y_OFFSET);
    wprintf(L"use 'a' and 'd' to select the character you want to play as; use \"enter\" to confirm");

    do{
        if(needRedraw){
            needRedraw = 0;

            selectedHero = heroes[currHeroOffset];
            if(selectedHeroRelic != NULL)(selectedHeroRelic);
            selectedHeroRelic = getHeroDefaultRelic(selectedHero->id);
            
            genList_Iterate(selectedHeroDeck,destroyCard);//need a pointer before?
            genList_DestroyAll(&selectedHeroDeck);
            selectedHeroDeck = getHeroDefaultDeck(selectedHero->id);
            

            for(i = 0; i <SHOWN_HEROES; i++){
                int index = (i+currHeroOffset+NUMBER_OF_PLAYABLE_CHARACTERS)%NUMBER_OF_PLAYABLE_CHARACTERS;
                drawFieldObjectSprite(CHARACTERS_X_OFFSET+i*(FIELD_CELL_WIDTH+2),CHARACTERS_Y_OFFSET,(*heroes[index]).spritesIds[i==0 ? 0:1]);
            }
            
            positionwPrintf(1,STATS_Y_OFFSET);
            setwPrintfColor(15,0);
            wprintf(L"\e[0Kcharacter: %Ls\n\e[0Khealth: %d/%d\n",selectedHero->name,selectedHero->maxHealt,selectedHero->maxHealt);
            wprintf(L"\nstarting relic:\n\e[0K%Ls | %Ls\n\nstarting deck:\n",selectedHeroRelic->name,selectedHeroRelic->description);
            cardTmp = selectedHeroDeck;
            while (cardTmp != NULL)
            {
                //wprintf(L"\e[0K%ls| %ls\n",((card_t *)(cardTmp->data))->name,L"ww");
                wprintf(L"\e[0K%ls | %ls\n",((card_t *)(cardTmp->data))->baseName,((card_t *)(cardTmp->data))->description);
                cardTmp = cardTmp->next;
            }
            
        }

        *ptrCommand = getch();
        if(*ptrCommand != COMMAND_QUIT){
            switch (*ptrCommand)
            {
            case 'a':
                currHeroOffset = (currHeroOffset-1+NUMBER_OF_PLAYABLE_CHARACTERS)%NUMBER_OF_PLAYABLE_CHARACTERS;
                needRedraw = 1;
                break;
            case 'd':
                currHeroOffset = (currHeroOffset+1)%NUMBER_OF_PLAYABLE_CHARACTERS;
                needRedraw = 1;
                break;
            case ENTER_ASHII_CODE:
                destroyLastGameInstance(game);

                //game seed
                srand(time(NULL));
                game->gameSeed = rand();// Returns a pseudo-random integer between 0 and RAND_MAX.
                game->gameSeedUses = 0;
                srand(game->gameSeed);

                //initialize hero
                for(i = 0; i < NUMBER_OF_PLAYABLE_CHARACTERS; i++){
                    if(heroes[i] != selectedHero){//can't do != with 2 structs
                        destroyFieldObject(heroes[i]);
                    }
                    
                }
                
                game->player.character = selectedHero;
                game->player.gold = STARTING_GOLD;

                //initialize relics
                game->player.relics = genList_createNode(selectedHeroRelic);
                game->relicsPool = getHeroRelicsPool(selectedHero->id);
                
                //initialize cards
                game->player.drawDeck = selectedHeroDeck;
                game->cardsPool = getHeroCardsPool(selectedHero->id);
                game->currCardRemovalCost = CARDS_BASE_REMOVE_COST;

                //initialize steps
                game->steps = 0;

                //map
                game->currMapPos = 0;
                initializeEventsChances(&(game->mapEventsChances),1);
                for(i = 0; i < MAP_COLUMS; i++){//"clear" the map
                    for(j = 0; j < MAP_ROWS; j++){
                        initializeSpecificMapEvent(&game->map[i][j],EVENT_EMPTY);
                    }
                }
                for(j = 0; j < MAP_ROWS && j < MAP_STARTING_OPTIONS; j++){//initialize first row
                    int tmp = legalRand(game)%MAP_ROWS;

                    while (game->map[MAP_COLUMS-1][tmp].id != EVENT_EMPTY){
                        tmp = legalRand(game)%MAP_ROWS;
                    }
                    
                    initializeSpecificMapEvent(&game->map[MAP_COLUMS-1][tmp],EVENT_NORMAL_FIGHT);
                }
                for(i = 0; i < MAP_COLUMS-2; i++){//generate the rest
                    furtherCreateMap(game);
                }

                game->currGameState = STATE_NAVIGATION;
                game->flagChangeGameState = 1;
                break;
            
            default:
                break;
            }
        }
    }while (*ptrCommand != COMMAND_QUIT && !game->flagChangeGameState);
    
    

}
void routineNavigation(char *ptrCommand, gameInstance_t *game){
	const int STEPS_ZEROS = 4;
	const int SIDE_SPACE = 35;
	const int CURR_FOCUS_INDICATORS_X_OFFSET = 25;
	const int CURR_FOCUS_INDICATORS_Y_OFFSET = 2;
	const int MAP_X_OFFSET = SIDE_SPACE+2;
	const int MAP_Y_OFFSET = 8;
	const int RELICS_X_OFFSET = 2;
	const int RELICS_Y_OFFSET = 8;
    const int MAX_SHOWN_RELICS = 8;
	const int CARDS_X_OFFSET = 2;
	const int CARDS_Y_OFFSET = RELICS_Y_OFFSET+MAX_SHOWN_RELICS+5;
    const int MAX_SHOWN_CARDS = 20;
	const int INFOS_Y_OFFSET = 53;
	const int GOLD_X_OFFSET = 14;
	const int GOLD_Y_OFFSET = 1;
    
    int i,j;
    navigationFocusses_e currFocus = NAV_FOCUS_MAP;
    int currIndex = 0,mapIndex = 0;
    int needRedraws[NAV_META_NUMBER_OF_OPTIONS];

    int cardsOffset = 0, cardsCurstor = 0, numberOfCards = genList_getLength(game->player.drawDeck);
    int relicsOffset = 0, relicsCurstor = 0, numberOfRelics = genList_getLength(game->player.relics);
    int mapCursor, oldMapCursor;
    int mapPosTmp;

    for(i = 0; i < NAV_META_NUMBER_OF_OPTIONS; i++){
        needRedraws[i] = 1;
    }
    needRedraws[NAV_FOCUS_MAP] = 0;

    if(game->steps == 0){
        mapCursor = 0;
        while(game->map[1][mapCursor].id == EVENT_EMPTY){
            mapCursor++;
        }
    }else{
        mapCursor = game->currMapPos;
        if(game->map[1][mapCursor].id == EVENT_EMPTY){
            if(mapCursor-1 >= 0 && game->map[1][mapCursor-1].id != EVENT_EMPTY){
                mapCursor--;
            }else{
                mapCursor++;
            }
        }
    }
    oldMapCursor = mapCursor;

    setwPrintfColor(15,0);
    system("cls");
    
    for(i = game->steps, j = STEPS_ZEROS-1; i > 9; i++){
    	i /= 10;
    	j--;
	}
	wprintf(L"steps:");
    for(; j > 0; j--){
    	wprintf(L"%d",0);
	}
	wprintf(L"%d",game->steps);
    wprintf(L"\n\n\n---------------%Ls----------------",game->player.character->name);
    positionwPrintf(RELICS_X_OFFSET,RELICS_Y_OFFSET);
    wprintf(L"relics: (%d)",numberOfRelics);
    positionwPrintf(CARDS_X_OFFSET,CARDS_Y_OFFSET);
    wprintf(L"cards: (%d)",numberOfCards);
    positionwPrintf(GOLD_X_OFFSET,GOLD_Y_OFFSET);
    wprintf(L"gold: %d",game->player.gold);

    
    for(i = 0; i < MAP_COLUMS; i++){//draw the map
        for(j = 0; j < MAP_ROWS; j++){
            if(i == 0){
                if(game->steps == 0 || j == game->currMapPos){
                    drawNavigationSprite((16+6)*i+MAP_X_OFFSET,(16+2)*j/2+MAP_Y_OFFSET,MAP_PLAYER_SPRITE_ID);
                }else{
                    if(game->map[i][j].id != EVENT_EMPTY)drawNavigationSprite((16+6)*i+MAP_X_OFFSET,(16+2)*j/2+MAP_Y_OFFSET,j == game->currMapPos ? game->map[i][j].spriteSelectdId : game->map[i][j].spriteId);
                }
            }else if(i == 1){
                if(game->map[i][j].id != EVENT_EMPTY)drawNavigationSprite((16+6)*i+MAP_X_OFFSET,(16+2)*j/2+MAP_Y_OFFSET,j == mapCursor ? game->map[i][j].spriteSelectdId : game->map[i][j].spriteId);
            }else{
                if(game->map[i][j].id != EVENT_EMPTY)drawNavigationSprite((16+6)*i+MAP_X_OFFSET,(16+2)*j/2+MAP_Y_OFFSET,game->map[i][j].spriteId);
            }
            

            //positionwPrintf((16+6)*i+MAP_X_OFFSET,(16+2)*j/2+MAP_Y_OFFSET);
            //setwPrintfColor(255,0);
            //wprintf(L"%d %d %d",i,j,game->map[i][j].id);
        }
    }
    

    do{
        //focus
        if(needRedraws[NAV_FOCUS_NULL]){
            needRedraws[NAV_FOCUS_NULL] = 0;

            //focus (order is important)
            if(currFocus == NAV_FOCUS_NULL){
                positionwPrintf(1,INFOS_Y_OFFSET);//comes first
                wprintf(L"\e[Kinfos:");//comes first
                positionwPrintf(CURR_FOCUS_INDICATORS_X_OFFSET,CURR_FOCUS_INDICATORS_Y_OFFSET);
                setwPrintfColor(15,0);
                wprintf(L"%Lsmap\t\t%Lsdeck\t\t%Lsrelics",currIndex == NAV_FOCUS_MAP ? L"->" : L"  ",currIndex == NAV_FOCUS_CARDS ? L"->" : L"  ",currIndex == NAV_FOCUS_RELICS ? L"->" : L"  ");
                
            }else{
                positionwPrintf(CURR_FOCUS_INDICATORS_X_OFFSET,CURR_FOCUS_INDICATORS_Y_OFFSET);
				setwPrintfColor(15,0);
                wprintf(L"%Lsmap\t\t%Lsdeck\t\t%Lsrelics",currFocus == NAV_FOCUS_MAP ? L"##" : L"  ",currFocus == NAV_FOCUS_CARDS ? L"##" : L"  ",currFocus == NAV_FOCUS_RELICS ? L"##" : L"  ");
            }

        }

        //cards
        if(needRedraws[NAV_FOCUS_CARDS]){
            needRedraws[NAV_FOCUS_CARDS] = 0;
            genericListNode_t *nodeTmp = genList_getNode(game->player.drawDeck,cardsOffset);

            positionwPrintf(CARDS_X_OFFSET,CARDS_Y_OFFSET+1);
            wprintf(L"%Ls\n",cardsOffset == 0 ? L"     " : L"  ...");

            for(i = 0; i < MAX_SHOWN_CARDS && nodeTmp != NULL; i++){
                wprintf(L"\e[%dC\e[%dC\e[1K\e[%dD%Ls%Ls\n",CARDS_X_OFFSET,CARD_FULL_NAME_MAX_LENGTH,CARD_FULL_NAME_MAX_LENGTH,currFocus == NAV_FOCUS_CARDS && i == cardsCurstor ? L"->" : L"  ",((card_t*)(nodeTmp->data))->fullName);
                nodeTmp = nodeTmp->next;
            }
            setwPrintf(CARDS_X_OFFSET,CARDS_Y_OFFSET+1+MAX_SHOWN_CARDS+1,255,0);
            wprintf(L"%Ls\n",cardsOffset+MAX_SHOWN_CARDS >= numberOfCards ? L"     " : L"  ...");
            
            if(currFocus == NAV_FOCUS_CARDS){
                positionwPrintf(1,INFOS_Y_OFFSET);
                wprintf(L"\e[Kinfos: %Ls",((card_t*)(genList_getNode(game->player.drawDeck,cardsOffset+cardsCurstor)->data))->description);
            }
        }

        //relics
        if(needRedraws[NAV_FOCUS_RELICS]){
            needRedraws[NAV_FOCUS_RELICS] = 0;
            genericListNode_t *nodeTmp = genList_getNode(game->player.relics,relicsOffset);

            positionwPrintf(RELICS_X_OFFSET,RELICS_Y_OFFSET+1);
            wprintf(L"%Ls\n",relicsOffset == 0 ? L"     " : L"  ...");

            for(i = 0; i < MAX_SHOWN_RELICS && nodeTmp != NULL; i++){
                wprintf(L"\e[%dC\e[1K\e[%dD\e[%dC%Ls%Ls\n",SIDE_SPACE,SIDE_SPACE,RELICS_X_OFFSET,currFocus == NAV_FOCUS_RELICS && i == relicsCurstor ? L"->" : L"  ",((card_t*)(nodeTmp->data))->baseName);
                nodeTmp = nodeTmp->next;
            }
            wprintf(L"%Ls\n",relicsOffset+MAX_SHOWN_RELICS >= numberOfRelics ? L"     " : L"  ...");
            
            if(currFocus == NAV_FOCUS_RELICS){
                positionwPrintf(1,INFOS_Y_OFFSET);
                wprintf(L"\e[Kinfos: %Ls",((relic_t*)(genList_getNode(game->player.relics,relicsOffset+relicsCurstor)->data))->description);
            }
        }

        //map
        if(needRedraws[NAV_FOCUS_MAP]){
            needRedraws[NAV_FOCUS_MAP] = 0;

        
            if(currFocus == NAV_FOCUS_MAP){
                drawNavigationSprite((16+6)*1+MAP_X_OFFSET,(16+2)*(oldMapCursor)/2+MAP_Y_OFFSET,game->map[1][oldMapCursor].spriteId);
                drawNavigationSprite((16+6)*1+MAP_X_OFFSET,(16+2)*(mapCursor)/2+MAP_Y_OFFSET,game->map[1][mapCursor].spriteSelectdId);

                positionwPrintf(1,INFOS_Y_OFFSET);
                setwPrintfColor(255,0);
                wprintf(L"\e[Kinfos: %Ls",game->map[1][mapCursor].name);
            }else{
                drawNavigationSprite((16+6)*1+MAP_X_OFFSET,(16+2)*mapCursor/2+MAP_Y_OFFSET,game->map[1][mapCursor].spriteId);
            }
        }


        *ptrCommand = getch();

        switch (currFocus)
        {
            case NAV_FOCUS_NULL:
                switch (*ptrCommand)
                {
                    case 'a':
                        currIndex = (currIndex-1+(NAV_META_NUMBER_OF_OPTIONS-1))%(NAV_META_NUMBER_OF_OPTIONS-1);
                        needRedraws[NAV_FOCUS_NULL] = 1;
                        break;
                    case 'd':
                        currIndex = (currIndex+1)%(NAV_META_NUMBER_OF_OPTIONS-1);
                        needRedraws[NAV_FOCUS_NULL] = 1;
                        break;
                    case 'w':break;
                    case 's':break;
                    case ENTER_ASHII_CODE:
                        needRedraws[currFocus] = 1;
                        currFocus = currIndex;
                        needRedraws[currIndex] = 1;
                        break;
                    case GO_BACK_ASHII_CODE:break;
                }
                break;
            case NAV_FOCUS_MAP:
                switch (*ptrCommand)
                {
                    case 'a':
                        
                        break;
                    case 'd':

                        break;
                    case 'w':
                        mapPosTmp = mapCursor-1;
                        while (mapPosTmp > 0 && (mapPosTmp > game->currMapPos-2 || game->steps == 0) && game->map[1][mapPosTmp].id == EVENT_EMPTY){
                            mapPosTmp--;
                        }
                        if(mapPosTmp >= 0 && (mapPosTmp > game->currMapPos-2 || game->steps == 0) && game->map[1][mapPosTmp].id != EVENT_EMPTY){
                            oldMapCursor = mapCursor;
                            mapCursor = mapPosTmp;
                            needRedraws[currFocus] = 1;
                        }
                        break;
                    case 's':
                        mapPosTmp = mapCursor+1;
                        while (mapPosTmp < MAP_ROWS-1 && (mapPosTmp < game->currMapPos+2 || game->steps == 0) && game->map[1][mapPosTmp].id == EVENT_EMPTY){
                            mapPosTmp++;
                        }
                        if(mapPosTmp < MAP_ROWS && (mapPosTmp<game->currMapPos+2 || game->steps == 0) && game->map[1][mapPosTmp].id != EVENT_EMPTY){
                            oldMapCursor = mapCursor;
                            mapCursor = mapPosTmp;
                            needRedraws[currFocus] = 1;
                        }
                        break;
                    case ENTER_ASHII_CODE:
                        furtherCreateMap(game);
                        game->currMapPos = mapCursor;
                        game->steps++;
                        game->currGameState = STATE_SHOP;
                        game->flagChangeGameState = 1;

                    break;
                    case GO_BACK_ASHII_CODE:
                        needRedraws[currFocus] = 1;
                        currFocus = NAV_FOCUS_NULL;
                        needRedraws[currFocus] = 1;
                    break;
                }
                break;
            case NAV_FOCUS_CARDS:
                switch (*ptrCommand)
                {
                    case 'a':break;
                    case 'd':break;
                    case 'w':
                        if(cardsCurstor == 0){
                            if(cardsOffset > 0){
                                cardsOffset--;
                                needRedraws[NAV_FOCUS_CARDS] = 1;
                            }
                        }else{
                            cardsCurstor--;
                            needRedraws[NAV_FOCUS_CARDS] = 1;
                        }
                        break;
                    case 's':
                        if(numberOfCards > cardsCurstor + cardsOffset + 1){
                            if(cardsCurstor == MAX_SHOWN_CARDS-1){
                                if(cardsOffset+MAX_SHOWN_CARDS < numberOfCards){
                                    cardsOffset++;
                                    needRedraws[NAV_FOCUS_CARDS] = 1;
                                }
                            }else{
                                cardsCurstor++;
                                needRedraws[NAV_FOCUS_CARDS] = 1;
                            }
                        }
                        break;
                    case ENTER_ASHII_CODE:
                        needRedraws[currFocus] = 1;
                        currFocus = NAV_FOCUS_NULL;
                        needRedraws[currFocus] = 1;
                        break;
                    case GO_BACK_ASHII_CODE:
                        needRedraws[currFocus] = 1;
                        currFocus = NAV_FOCUS_NULL;
                        needRedraws[currFocus] = 1;
                    break;
                }
                break;
            case NAV_FOCUS_RELICS:
                switch (*ptrCommand)
                {
                    case 'a':
                        
                        break;
                    case 'd':

                        break;
                    case 'w':
                        if(relicsCurstor == 0){
                            if(relicsOffset > 0){
                                relicsOffset--;
                                needRedraws[currFocus] = 1;
                            }
                        }else{
                            relicsCurstor--;
                            needRedraws[currFocus] = 1;
                        }
                        break;
                    case 's':
                        if(numberOfRelics > relicsCurstor + relicsOffset + 1){
                            if(relicsCurstor == MAX_SHOWN_RELICS-1){
                                if(relicsOffset+MAX_SHOWN_RELICS < numberOfRelics){
                                    relicsOffset++;
                                    needRedraws[currFocus] = 1;
                                }
                            }else{
                                relicsCurstor++;
                                needRedraws[currFocus] = 1;
                            }
                        }
                        break;
                    case ENTER_ASHII_CODE:
                        needRedraws[currFocus] = 1;
                        currFocus = NAV_FOCUS_NULL;
                        needRedraws[currFocus] = 1;
                        break;
                    case GO_BACK_ASHII_CODE:
                        needRedraws[currFocus] = 1;
                        currFocus = NAV_FOCUS_NULL;
                        needRedraws[currFocus] = 1;
                    break;
                }
                break;
        }
    }while (*ptrCommand != COMMAND_QUIT && !game->flagChangeGameState);
    
    game->currGameState = STATE_BATTLING;
    //game->currGameState = STATE_SHOP;

}
void routineChest(char *ptrCommand, gameInstance_t *game){
    int state = 0;
    int cursor = 0;
    int needRedraw = 1;
    int nOptions = 2;
    int availableRelics = genList_getLength(game->relicsPool);
    int firstDraw = 1;

    genericListNode_t *node = NULL;

    system("cls");
    if(availableRelics > 0){
        node = genList_getNode(game->relicsPool,legalRand(game)%availableRelics);
    }
    

    do{
        if(needRedraw){
            needRedraw = 0;
            switch (state){
            case 0:
                drawGuiSprite(10,15,9);
                break;
            case 1:
                if(firstDraw){
                    //setwPrintfColor(255, 0);
                    //wprintf(L"%d",availableRelics);

                    drawGuiSprite(10,15,10);
                    if(availableRelics > 0){
                        drawRelicSprite(23,6,((relic_t *)node->data)->spritesIds[0]);

                        setwPrintfColor(255, 0);
                        positionwPrintf(10,9+25);
                        wprintf(L"%ls:",((relic_t *)node->data)->name);
                        positionwPrintf(10,9+25+1);
                        wprintf(L"%ls",((relic_t *)node->data)->description);
                    }else{
                        setwPrintfColor(255, 0);
                        positionwPrintf(10,9+25);
                        wprintf(L"no relics availabes");
                    }
                    firstDraw = 0;
                }
                setwPrintfColor(255, 0);
                positionwPrintf(18,12+25);
                wprintf(L"%lsaccept    %lsdecline", cursor == 0 ? L"->":L"  ", cursor == 1 ? L"->":L"  ");
                
                break;
            }
        }

        *ptrCommand = getch();
            if(*ptrCommand != COMMAND_QUIT){
                switch (state){
                    case 0:
                        state++;
                        needRedraw = 1;
                    break;
                    case 1:
                        switch (*ptrCommand)
                        {
                        case 'a':
                            cursor = (cursor+nOptions-1)%nOptions;
                        needRedraw = 1;
                        break;
                        case 'd':
                            cursor = (cursor+1)%nOptions;
                        needRedraw = 1;
                        break;
                        case ENTER_ASHII_CODE:
                            if(cursor == 0 && availableRelics > 0){
                                genList_removeNode(&(game->relicsPool),node);
                                genList_AddEnd(&(game->player.relics),node);
                            }
                            game->currGameState = STATE_NAVIGATION;
                            game->flagChangeGameState = 1;
                        break;
                        }
                    break;
                }
            }
    }while (*ptrCommand != COMMAND_QUIT && !game->flagChangeGameState);
    
    

}
void routineShop(char *ptrCommand, gameInstance_t *game){
    const int NUMBER_OF_FOCUSSUES = 3;
    const int NUMBER_OF_CARDS = 6;
    const int NUMBER_OF_RELICS = 3;
    const int GOLD_X_OFFSET = 3;
    const int GOLD_Y_OFFSET = 3;
    const int CARDS_X_OFFSET = 6;
    const int CARDS_Y_OFFSET = GOLD_Y_OFFSET+5;
    const int RELICS_X_OFFSET = CARDS_X_OFFSET;
    const int RELICS_Y_OFFSET = CARDS_Y_OFFSET+21;
    const int INFO_X_OFFSET = 2;
    const int INFO_Y_OFFSET = RELICS_Y_OFFSET+11;
    const int CARDS_SELECTION_X_OFFSET = INFO_X_OFFSET;
    const int CARDS_SELECTION_Y_OFFSET = INFO_Y_OFFSET;
    const int CARDS_SELECTION_SHOWN_CARDS = 12;
    const int CARDS_SELECTION_INFO_X_OFFSET = CARDS_SELECTION_X_OFFSET;
    const int CARDS_SELECTION_INFO_Y_OFFSET = CARDS_SELECTION_Y_OFFSET+3+CARDS_SELECTION_SHOWN_CARDS;
    int cursorCards = 0, cursorRelics = 0, lastCursor = 0;
    int needRedraw[NUMBER_OF_FOCUSSUES];
    int focus = 0;
    int nOptions = 2;
    int firstDraw = 1;
    int i,j,tmp1,tmp2;
    int notEnoughGoldFlag = 0, needRedrawGold = 1;
    genericListNode_t *cards[NUMBER_OF_CARDS],*relics[NUMBER_OF_RELICS];
    int cardsOffset = 0, numberOfCards = genList_getLength(game->player.drawDeck), cardsCurstor = 0;

    for(i = 0; i < NUMBER_OF_FOCUSSUES; i++){
        needRedraw[i] = 0;
    }

    system("cls");
    setwPrintfColor(255,0);
    wprintf(L"press q to exit the shop");
    wprintf(L"\e[%d;%dHcards:",CARDS_Y_OFFSET-2,2);
    wprintf(L"\e[%d;%dHrelics:",RELICS_Y_OFFSET-2,2);
    j = genList_getLength(game->cardsPool);
    if(genList_getLength(game->cardsPool) > 0){
        for(i = 0; i < NUMBER_OF_CARDS; i++){
            if(focus == 0 && i == cursorCards){
                drawGuiSprite(CARDS_X_OFFSET+i*24-2,CARDS_Y_OFFSET-1,12);
            }
            if(i == 0){
                cards[i] == game->cardsPool;
                drawGuiSprite(CARDS_X_OFFSET+i*24,CARDS_Y_OFFSET,11);
            }else{
                cards[i] = genList_getNode(game->cardsPool,normalRand()%j);
                if(cards[i] != NULL){
                    drawCard(CARDS_X_OFFSET+i*24,CARDS_Y_OFFSET,(card_t*)(cards[i]->data));
                }else{
                    drawGuiSprite(CARDS_X_OFFSET+i*24,CARDS_Y_OFFSET,16);
                }
            }
        }
    }
    j = genList_getLength(game->relicsPool);
    for(i = 0; i < NUMBER_OF_RELICS && i < j; i++){
        if(focus == 1 && i == cursorRelics){
            drawGuiSprite(RELICS_X_OFFSET+i*24-2,RELICS_Y_OFFSET-1,14);
        }

        relics[i] = genList_getNode(game->relicsPool,normalRand()%j);
        do{//prevent copies of the same relic from showing up
            tmp1 = 1;
            for(tmp2 = 0; tmp2 < i && tmp1; tmp2++){
                if(relics[i]->data == relics[tmp2]->data){
                    tmp1 = 0;
                    relics[i] = relics[i]->next;
                    if(relics[i] == NULL){
                        relics[i] = game->relicsPool;
                    }
                }
            }
        }while (!tmp1);
        
        if(relics[i] != NULL){
            drawRelicSprite(RELICS_X_OFFSET+i*24,RELICS_Y_OFFSET,((relic_t*)(relics[i]->data))->spritesIds[0]);
        }else{
            drawGuiSprite(RELICS_X_OFFSET+i*24,RELICS_Y_OFFSET,17);
        }
    }
    setwPrintf(INFO_X_OFFSET,INFO_Y_OFFSET,255,0);
    wprintf(L"\e[K%d | remove: remove a card from your deck",game->currCardRemovalCost);
    drawGuiSprite(155,7,18);

    do{
        if(needRedrawGold){
            needRedrawGold = 0;
            setwPrintf(GOLD_X_OFFSET,GOLD_Y_OFFSET,255,0);
            wprintf(L"\e[Kgold: %d",game->player.gold);
        }
        if(needRedraw[0]){//cards
            needRedraw[0] = 0;
            if(focus == 0){
                drawGuiSprite(CARDS_X_OFFSET+lastCursor*24-2,CARDS_Y_OFFSET-1,13);
                if(lastCursor == 0){
                    drawGuiSprite(CARDS_X_OFFSET+lastCursor*24,CARDS_Y_OFFSET,cards[0] == NULL ? 16 : 11);
                }else{
                    if(cards[lastCursor] != NULL){
                        drawCard(CARDS_X_OFFSET+lastCursor*24,CARDS_Y_OFFSET,(card_t*)(cards[lastCursor]->data));
                    }else{
                        drawGuiSprite(CARDS_X_OFFSET+lastCursor*24,CARDS_Y_OFFSET,16);
                    }
                    
                }
                drawGuiSprite(CARDS_X_OFFSET+cursorCards*24-2,CARDS_Y_OFFSET-1,12);
                setwPrintf(INFO_X_OFFSET,INFO_Y_OFFSET,255,0);
                if(notEnoughGoldFlag){
                    notEnoughGoldFlag = 0;
                    wprintf(L"\e[Knot enough gold");
                }else{
                    if(cursorCards == 0){
                        if(cards[0] != NULL){
                            wprintf(L"\e[K%d | remove: remove a card from your deck",game->currCardRemovalCost);
                        }else{
                            wprintf(L"\e[K");
                        }
                    }else{
                        if(cards[cursorCards] != NULL){
                            wprintf(L"\e[K%d | %Ls: %Ls",CARDS_COSTS[((card_t*)(cards[cursorCards]->data))->rarity],((card_t*)(cards[cursorCards]->data))->fullName,((card_t*)(cards[cursorCards]->data))->description);
                        }else{
                            wprintf(L"\e[K");
                        }
                    }
                }
            }else{
                drawGuiSprite(CARDS_X_OFFSET+cursorCards*24-2,CARDS_Y_OFFSET-1,13);
            }
            if(cursorCards == 0){
                drawGuiSprite(CARDS_X_OFFSET+cursorCards*24,CARDS_Y_OFFSET,cards[0] == NULL ? 16 : 11);
            }else{
                if(cards[cursorCards] != NULL){
                    drawCard(CARDS_X_OFFSET+cursorCards*24,CARDS_Y_OFFSET,(card_t*)(cards[cursorCards]->data));
                }else{
                    drawGuiSprite(CARDS_X_OFFSET+cursorCards*24,CARDS_Y_OFFSET,16);
                }
                
            }
        }
        if(needRedraw[1]){//relics
            needRedraw[1] = 0;
            if(focus == 1){
                drawGuiSprite(RELICS_X_OFFSET+lastCursor*24-2,RELICS_Y_OFFSET-1,15);
                if(relics[lastCursor] != NULL){
                    drawRelicSprite(CARDS_X_OFFSET+lastCursor*24,RELICS_Y_OFFSET,((relic_t*)(relics[lastCursor]->data))->spritesIds[0]);
                }else{
                    drawGuiSprite(RELICS_X_OFFSET+lastCursor*24,RELICS_Y_OFFSET,17);
                }
                drawGuiSprite(RELICS_X_OFFSET+cursorRelics*24-2,RELICS_Y_OFFSET-1,14);
                setwPrintf(INFO_X_OFFSET,INFO_Y_OFFSET,255,0);
                if(notEnoughGoldFlag){
                    notEnoughGoldFlag = 0;
                    wprintf(L"\e[Knot enough gold");
                }else{
                    if(relics[cursorRelics] != NULL){
                        wprintf(L"\e[K%d | %Ls: %Ls",RELICS_COST,((relic_t*)(relics[cursorRelics]->data))->name,((relic_t*)(relics[cursorRelics]->data))->description);
                    }else{
                        wprintf(L"\e[K");
                    }
                }
            }else{
                drawGuiSprite(RELICS_X_OFFSET+cursorRelics*24-2,RELICS_Y_OFFSET-1,15);
            }
            if(relics[cursorRelics] != NULL){
                drawRelicSprite(CARDS_X_OFFSET+cursorRelics*24,RELICS_Y_OFFSET,((relic_t*)(relics[cursorRelics]->data))->spritesIds[0]);
            }else{
                drawGuiSprite(RELICS_X_OFFSET+cursorRelics*24,RELICS_Y_OFFSET,17);
            }
            
        }
        if(needRedraw[2]){//cards selection
            needRedraw[2] = 0;
            if(focus == 2){
                genericListNode_t *nodeTmp = genList_getNode(game->player.drawDeck,cardsOffset);
                setwPrintf(CARDS_SELECTION_X_OFFSET,CARDS_SELECTION_Y_OFFSET,255,0);
                wprintf(L"\e[Kchoose a card to remove from your deck\n");
                setwPrintf(CARDS_SELECTION_X_OFFSET,CARDS_SELECTION_Y_OFFSET+1,255,0);
                wprintf(L"%Ls\n",cardsOffset == 0 ? L"     " : L"  ...");
    
                for(i = 0; i < CARDS_SELECTION_SHOWN_CARDS && nodeTmp != NULL; i++){
                    wprintf(L"\e[%dC\e[%dC\e[1K\e[%dD%Ls%Ls\n",CARDS_SELECTION_X_OFFSET,CARD_FULL_NAME_MAX_LENGTH,CARD_FULL_NAME_MAX_LENGTH,i == cardsCurstor ? L"->" : L"  ",((card_t*)(nodeTmp->data))->fullName);
                    nodeTmp = nodeTmp->next;
                }
                setwPrintf(CARDS_SELECTION_X_OFFSET,CARDS_SELECTION_Y_OFFSET+1+CARDS_SELECTION_SHOWN_CARDS+1,255,0);
                wprintf(L"%Ls\n",cardsOffset+CARDS_SELECTION_SHOWN_CARDS >= numberOfCards ? L"     " : L"  ...");
                setwPrintf(CARDS_SELECTION_X_OFFSET,CARDS_SELECTION_Y_OFFSET+1+CARDS_SELECTION_SHOWN_CARDS+2,255,0);
                wprintf(L"\e[K%Ls\n",((card_t *)genList_getNode(game->player.drawDeck,cardsCurstor+cardsOffset)->data)->description);
            }else{
                positionwPrintf(1,CARDS_SELECTION_Y_OFFSET);
                for(i = 0; i < CARDS_SELECTION_SHOWN_CARDS+3; i++){
                    wprintf(L"\e[K\n");
                }
            }

        }


        *ptrCommand = getch();
            if(*ptrCommand != COMMAND_QUIT){
                switch (*ptrCommand){
                    case 'w':
                        if(focus == 0 || focus == 1){
                            needRedraw[focus] = 1;
                            focus = (focus+NUMBER_OF_FOCUSSUES-1)%NUMBER_OF_FOCUSSUES;
                            needRedraw[focus] = 1;
                            switch (focus){
                                case 0:
                                    lastCursor = cursorCards;
                                break;
                                case 1:
                                    lastCursor = cursorRelics;
                                break;
                            }
                        }else{
                            if(cardsCurstor == 0){
                                if(cardsOffset > 0){
                                    cardsOffset--;
                                    needRedraw[focus] = 1;
                                }
                            }else{
                                cardsCurstor--;
                                needRedraw[focus] = 1;
                            }
                        }
                    break;
                    case 's':
                        if(focus == 0 || focus == 1){
                            needRedraw[focus] = 1;
                            focus = (focus+1)%NUMBER_OF_FOCUSSUES;
                            needRedraw[focus] = 1;
                            switch (focus){
                                case 0:
                                    lastCursor = cursorCards;
                                break;
                                case 1:
                                    lastCursor = cursorRelics;
                                break;
                            }
                        }else{
                            if(numberOfCards > cardsCurstor + cardsOffset + 1){
                                if(cardsCurstor == CARDS_SELECTION_SHOWN_CARDS-1){
                                    if(cardsOffset+CARDS_SELECTION_SHOWN_CARDS < numberOfCards){
                                        cardsOffset++;
                                        needRedraw[focus] = 1;
                                    }
                                }else{
                                    cardsCurstor++;
                                    needRedraw[focus] = 1;
                                }
                            }
                        }
                    break;
                    case 'd':
                        if(focus == 0 || focus == 1){
                            switch (focus){
                                case 0:
                                    lastCursor = cursorCards;
                                    cursorCards = (cursorCards+1)%NUMBER_OF_CARDS;
                                    needRedraw[focus] = 1;
                                break;
                                case 1:
                                    lastCursor = cursorRelics;
                                    cursorRelics = (cursorRelics+1)%NUMBER_OF_RELICS;
                                    needRedraw[focus] = 1;
                                break;
                            }
                        }
                    break;
                    case 'a':
                        if(focus == 0 || focus == 1){
                            switch (focus){
                                case 0:
                                    lastCursor = cursorCards;
                                    cursorCards = (cursorCards+NUMBER_OF_CARDS-1)%NUMBER_OF_CARDS;
                                    needRedraw[focus] = 1;
                                break;
                                case 1:
                                    lastCursor = cursorRelics;
                                    cursorRelics = (cursorRelics+NUMBER_OF_RELICS-1)%NUMBER_OF_RELICS;
                                    needRedraw[focus] = 1;
                                break;
                            }
                        }
                    break;
                    case ENTER_ASHII_CODE:
                        switch (focus){
                            case 0:
                                if(cursorCards == 0){
                                    if(game->player.gold >= game->currCardRemovalCost){
                                        game->player.gold -= game->currCardRemovalCost;
                                        game->currCardRemovalCost += CARDS_INCREMENT_COST;
                                        needRedrawGold = 1;
                                        cards[0] = NULL;
                                        focus = 2;
                                        needRedraw[0] = 1;
                                        needRedraw[2] = 1;
                                        cardsOffset = 0;
                                        numberOfCards = genList_getLength(game->player.drawDeck);
                                        cardsCurstor = 0;
                                    }else{
                                        notEnoughGoldFlag = 1;
                                    }
                                    needRedraw[0] = 1;
                                }else{
                                    if(cards[cursorCards] != NULL){
                                        if(game->player.gold >= CARDS_COSTS[((card_t *)cards[cursorCards]->data)->rarity]){
                                            game->player.gold -= CARDS_COSTS[((card_t *)cards[cursorCards]->data)->rarity];
                                            needRedrawGold = 1;
                                            genList_AddStart(&game->player.drawDeck,genList_createNode(createCard(((card_t *)cards[cursorCards]->data)->id)));
                                            cards[cursorCards] = NULL;
                                        }else{
                                            notEnoughGoldFlag = 1;
                                        }
                                        needRedraw[0] = 1;
                                    }
                                }
                            break;
                            case 1:
                                if(relics[cursorRelics] != NULL){
                                    if(game->player.gold >= RELICS_COST){
                                        game->player.gold -= RELICS_COST;
                                        needRedrawGold = 1;
                                        genList_removeNode(&game->relicsPool,relics[cursorRelics]);
                                        genList_AddStart(&game->player.relics,relics[cursorRelics]);
                                        relics[cursorRelics] = NULL;
                                    }else{
                                        notEnoughGoldFlag = 1;
                                    }
                                    needRedraw[1] = 1;
                                }
                            break;
                            case 2:
                                focus = 0;
                                needRedraw[0] = 1;
                                needRedraw[2] = 1;
                                destroyCard(genList_getNode(game->player.drawDeck,cardsOffset+cardsCurstor)->data);
                                genList_DestroyNode(genList_removeNodeAt(&game->player.drawDeck,cardsOffset+cardsCurstor));
                            break;
                        }
                    break;
                    case 'q':
                        game->currGameState = STATE_NAVIGATION;
                        game->flagChangeGameState = 1;
                    break;
                }
            }
    }while (*ptrCommand != COMMAND_QUIT && !game->flagChangeGameState);
    
    
}
void routineAnvil(char *ptrCommand, gameInstance_t *game){
    if(genList_getLength(game->player.drawDeck) >= 2){
        const int NUMBER_OF_FOCUSSES = 4;
        const int CARDS_SELECTION_X_OFFSET = 3;
        const int CARDS_SELECTION_Y_OFFSET = 3;
        const int CARDS_SELECTION_INFO_X_OFFSET = 3;
        const int CARDS_SELECTION_INFO_Y_OFFSET = 50;
        const int CARDS_SELECTION_SHOWN_CARDS = 12;
        const int GUI_X_START = 50;
        const int GUI_Y_START = 5;
        int needRedraw[NUMBER_OF_FOCUSSES];
        int focus;
        int cursorCards = 0, cursorRelics = 0, lastCursor = 0;
        int i,j;
        int cardsOffset = 0, numberOfCards = genList_getLength(game->player.drawDeck), cardsCurstor = 0;
        int lastFocus = 3;
        genericListNode_t *cardToUpgrade = NULL,*cardToDestroy = NULL;
        card_t *resultCard = NULL;

        for( i = 0; i < NUMBER_OF_FOCUSSES; i++){
            needRedraw[i] = 1;
        }

        system("cls");
        drawGuiSprite(83,23,24);

        do{
            if(needRedraw[0] || needRedraw[1] || needRedraw[2] || needRedraw[3]){
                drawRect(CARDS_SELECTION_INFO_X_OFFSET,CARDS_SELECTION_INFO_Y_OFFSET,0,CARD_DESCRIPTION_MAX_LENGTH,1);
            }
            if(needRedraw[0]){//pugrade card
                needRedraw[0] = 0;
                drawGuiSprite(GUI_X_START-2,GUI_Y_START-1,focus == 0 ? 22 : 23);
                if(cardToUpgrade != NULL){
                    drawCard(GUI_X_START,GUI_Y_START,cardToUpgrade->data);
                    if(focus == 0){
                        setwPrintf(CARDS_SELECTION_INFO_X_OFFSET,CARDS_SELECTION_INFO_Y_OFFSET,255,0);
                        wprintf(L"%Ls\n",((card_t *)cardToUpgrade->data)->description);
                    }
                }else{
                    drawGuiSprite(GUI_X_START,GUI_Y_START,19);
                }
                
            }
            if(needRedraw[1]){//sacrifice card
                needRedraw[1] = 0;
                drawGuiSprite(GUI_X_START-2,GUI_Y_START+23-1,focus == 1 ? 22 : 23);
                if(cardToDestroy != NULL){
                    drawCard(GUI_X_START,GUI_Y_START+23,cardToDestroy->data);
                    if(focus == 1){
                        setwPrintf(CARDS_SELECTION_INFO_X_OFFSET,CARDS_SELECTION_INFO_Y_OFFSET,255,0);
                        wprintf(L"%Ls\n",((card_t *)cardToDestroy->data)->description);
                    }
                }else{
                    drawGuiSprite(GUI_X_START,GUI_Y_START+23,20);
                }
                
            }
            if(needRedraw[2]){//resuld card
                needRedraw[2] = 0;
                drawGuiSprite(GUI_X_START+45-2,GUI_Y_START-1,focus == 2 ? 22 : 23);

                if(cardToDestroy != NULL && cardToUpgrade != NULL){
                    if(resultCard != NULL){
                        destroyCard(resultCard);
                    }
                    //add the levels of the 2 cards; add 1 if the destroy card is level 0;
                    int newLevel = ((card_t *)cardToUpgrade->data)->level + (((card_t *)cardToDestroy->data)->level == 0 ? 1 : ((card_t *)cardToDestroy->data)->level);
                    resultCard = createCardLevel(((card_t *)cardToUpgrade->data)->id,newLevel);
                    
                    drawCard(GUI_X_START+45,GUI_Y_START,resultCard);
                    if(focus == 2){
                        setwPrintf(CARDS_SELECTION_INFO_X_OFFSET,CARDS_SELECTION_INFO_Y_OFFSET,255,0);
                        wprintf(L"%Ls\n",resultCard->description);
                    }

                }else{
                    resultCard = NULL;
                    drawGuiSprite(GUI_X_START+45,GUI_Y_START,21);
                }

            }
            if(needRedraw[3]){//card selection
                needRedraw[3] = 0;
                genericListNode_t *nodeTmp = genList_getNode(game->player.drawDeck,cardsOffset);
                setwPrintf(CARDS_SELECTION_X_OFFSET,CARDS_SELECTION_Y_OFFSET,255,0);
                if(focus == 3){
                    if(lastFocus == 0){
                        wprintf(L"\e[Kchoose the card to upgrade\n");
                    }else if(lastFocus == 1){
                        wprintf(L"\e[Kchoose the card to destroy\n");
                    }
                }else{
                    wprintf(L"\e[K");
                }
                
                setwPrintf(CARDS_SELECTION_X_OFFSET,CARDS_SELECTION_Y_OFFSET+1,255,0);
                wprintf(L"%Ls\n",cardsOffset == 0 ? L"     " : L"  ...");

                for(i = 0; i < CARDS_SELECTION_SHOWN_CARDS && nodeTmp != NULL; i++){
                    if(focus == 3 && i == cardsCurstor){
                        wprintf(L"\e[%dC\e[%dC\e[1K\e[%dD%Ls%Ls\n",CARDS_SELECTION_X_OFFSET,CARD_FULL_NAME_MAX_LENGTH,CARD_FULL_NAME_MAX_LENGTH,L"->",((card_t*)(nodeTmp->data))->fullName);
                    }
                    else if(cardToDestroy == nodeTmp){
                        wprintf(L"\e[%dC\e[%dC\e[1K\e[%dD%Ls%Ls\n",CARDS_SELECTION_X_OFFSET,CARD_FULL_NAME_MAX_LENGTH,CARD_FULL_NAME_MAX_LENGTH,L"\e[38;5;1m #\e[38;5;255m",((card_t*)(nodeTmp->data))->fullName);
                    }
                    else if (cardToUpgrade == nodeTmp){
                        wprintf(L"\e[%dC\e[%dC\e[1K\e[%dD%Ls%Ls\n",CARDS_SELECTION_X_OFFSET,CARD_FULL_NAME_MAX_LENGTH,CARD_FULL_NAME_MAX_LENGTH,L"\e[38;5;2m #\e[38;5;255m",((card_t*)(nodeTmp->data))->fullName);
                    }
                    else{
                        wprintf(L"\e[%dC\e[%dC\e[1K\e[%dD%Ls%Ls\n",CARDS_SELECTION_X_OFFSET,CARD_FULL_NAME_MAX_LENGTH,CARD_FULL_NAME_MAX_LENGTH,L"  ",((card_t*)(nodeTmp->data))->fullName);
                    }
                    
                    
                    
                    nodeTmp = nodeTmp->next;
                }
                setwPrintf(CARDS_SELECTION_X_OFFSET,CARDS_SELECTION_Y_OFFSET+1+CARDS_SELECTION_SHOWN_CARDS+1,255,0);
                wprintf(L"%Ls\n",cardsOffset+CARDS_SELECTION_SHOWN_CARDS >= numberOfCards ? L"     " : L"  ...");
                if(focus == 3){
                    setwPrintf(CARDS_SELECTION_INFO_X_OFFSET,CARDS_SELECTION_INFO_Y_OFFSET,255,0);
                    wprintf(L"%Ls\n",((card_t *)genList_getNode(game->player.drawDeck,cardsCurstor+cardsOffset)->data)->description);
                }
                
            }
            

            *ptrCommand = getch();
                if(*ptrCommand != COMMAND_QUIT){
                    switch (*ptrCommand){
                        case 'w':
                            if(focus == 1 || focus == 2){
                                needRedraw[focus] = 1;
                                lastFocus = focus;
                                focus = 0;
                                needRedraw[focus] = 1;
                            }else if(focus == 3){
                                if(cardsCurstor == 0){
                                    if(cardsOffset > 0){
                                        cardsOffset--;
                                        needRedraw[focus] = 1;
                                    }
                                }else{
                                    cardsCurstor--;
                                    needRedraw[focus] = 1;
                                }
                            }
                        break;
                        case 's':
                            if(focus == 0 || focus == 2){
                                needRedraw[focus] = 1;
                                lastFocus = focus;
                                focus = 1;
                                needRedraw[focus] = 1;
                            }else if(focus == 3){
                                if(numberOfCards > cardsCurstor + cardsOffset + 1){
                                    if(cardsCurstor == CARDS_SELECTION_SHOWN_CARDS-1){
                                        if(cardsOffset+CARDS_SELECTION_SHOWN_CARDS < numberOfCards){
                                            cardsOffset++;
                                            needRedraw[focus] = 1;
                                        }
                                    }else{
                                        cardsCurstor++;
                                        needRedraw[focus] = 1;
                                    }
                                }
                            
                            }
                        break;
                        case 'd':
                            if (focus == 0 || focus == 1){
                                needRedraw[focus] = 1;
                                lastFocus = focus;
                                focus = 2;
                                needRedraw[focus] = 1;
                            }
                        break;
                        case 'a':
                            if (focus == 2){
                                int tmp = focus;
                                needRedraw[focus] = 1;
                                focus = lastFocus;
                                lastFocus = tmp;
                                needRedraw[focus] = 1;
                            }
                        break;
                        case ENTER_ASHII_CODE:
                            if(focus == 0 || focus == 1){
                                needRedraw[focus] = 1;
                                lastFocus = focus;
                                focus = 3;
                                needRedraw[focus] = 1;
                            }
                            else if (focus == 3){
                                needRedraw[focus] = 1;
                                int tmp = focus;
                                focus = lastFocus;
                                lastFocus = tmp;
                                needRedraw[focus] = 1;
                                needRedraw[2] = 1;
                                if(focus == 0){
                                    cardToUpgrade = genList_getNode(game->player.drawDeck,cardsCurstor+cardsOffset);
                                    if(cardToDestroy == cardToUpgrade){
                                        cardToDestroy = NULL;
                                        needRedraw[1] = 1;
                                    }
                                }else if(focus == 1){
                                    cardToDestroy = genList_getNode(game->player.drawDeck,cardsCurstor+cardsOffset);
                                    if(cardToDestroy == cardToUpgrade){
                                        cardToUpgrade = NULL;
                                        needRedraw[0] = 1;
                                    }
                                }
                            }
                            else if(focus == 2){
                                destroyCard(cardToDestroy->data);
                                genList_removeNode(&game->player.drawDeck,cardToDestroy);
                                genList_DestroyNode(cardToDestroy);
                                setCardLevel(cardToUpgrade->data,resultCard->level);
                                destroyCard(resultCard);
                                game->currGameState = STATE_NAVIGATION;
                                game->flagChangeGameState = 1;
                            }
                        break;
                        case 'q':
                            //game->currGameState = STATE_NAVIGATION;
                            //game->flagChangeGameState = 1;
                        break;
                    }
                }
        }while (*ptrCommand != COMMAND_QUIT && !game->flagChangeGameState);
    
    }else{
        game->currGameState = STATE_NAVIGATION;
        game->flagChangeGameState = 1;
    }
    
}
void routineRestSite(char *ptrCommand, gameInstance_t *game){
    int hpToHeal = 3;


    if(hpToHeal > game->player.character->maxHealt - game->player.character->currHealth){
        hpToHeal = game->player.character->maxHealt - game->player.character->currHealth;
    }
    game->player.character->currHealth += hpToHeal;

    system("cls");
    setwPrintf(12,3,255,0);
    wprintf(L"you healed %d hp%Ls",hpToHeal,game->player.character->maxHealt == game->player.character->currHealth ? L" to max!" : L"");
    drawGuiSprite(2,5,25);
    setwPrintf(2,22,255,0);
    wprintf(L"%d/%d hp",game->player.character->currHealth,game->player.character->maxHealt);

    

    *ptrCommand = getch();
    game->currGameState = STATE_NAVIGATION;
    game->flagChangeGameState = 1;

}
void routineBattle(char *ptrCommand, gameInstance_t *game){
    const int STARTING_MUVES = 2;
    const int FOCUSSES = 4;//field,effects,cards,move
    const int HAND_SIZE = 5;
    const int FIELD_START_X = 7;
    const int FIELD_START_Y = 13;
    const int CARDS_START_X = 38;
    const int CARDS_START_Y = 35;
    player_t player = game->player;
    int i,tmp;
    int turnsCounter = 1;
    int updateLife = 1, updateDeckInfo = 1,updateMuves = 1, updateTurns = 1,redrawMainSection = 1,updateMainSection = 0;
    int numberOfRelice = genList_getLength(player.relics);genericListNode_t *relics[numberOfRelice];
    int fieldSize = 7;fieldObject_t *field[fieldSize];
    genericListNode_t *hand[HAND_SIZE];
    int focus = 2;
    int handCursor = HAND_SIZE/2, lastHandCursor = HAND_SIZE/2;

    //initialize the battle
    player.muves = STARTING_MUVES;
    genList_shouffle(&(player.drawDeck));
    for(i = 0; i < HAND_SIZE; i++){
        hand[i] = genList_removeNodeAt(&player.drawDeck,0);
    }
    for(i = 0; i < fieldSize; i++){
        if(i == (fieldSize/2)){
            field[i] = player.character;
        }else{
            field[i] = NULL;
        }
    }
    


    system("cls");
    for(i = 0; i < numberOfRelice; i++){
        relics[i] = (i == 0 ? player.relics : relics[i-1]->next);
        drawRelic(40 + i*18,1,relics[i]->data);
    }
    for(i = 0; i < fieldSize; i++){
        if(field[i] == NULL){
            drawFieldObjectSprite(FIELD_START_X + i*28,FIELD_START_Y,3);
        }else{
            drawFieldObjectSprite(FIELD_START_X + i*28,FIELD_START_Y,field[i]->spritesIds[field[i]->facingLeft]);
        }
        if(i < 5){
            drawGuiSprite(FIELD_START_X + i*28,FIELD_START_Y+16,26+i);
        }else{
            drawGuiSprite(FIELD_START_X + i*28,FIELD_START_Y+16,26);
        }
        /*
        if(field[i] != NULL){
            drawGuiSprite(7 + i*28 +(field[i]->facingLeft ? 2 : 22),16+1,31);
        }*/
        
        
    }
    
    do{

        if(updateTurns){
            updateTurns = 0;
            setwPrintf(4,2,255,0);
            wprintf(L"turn %d",turnsCounter);
        }
        if(updateLife){
            updateLife = 0;
            setwPrintfColor(1,1);
            for(i = 0; i < player.character->maxHealt; i++){
                wprintf(L"\e[4;%dH\e[48;5;%dm  ",4+i*3,player.character->currHealth > i ? 1 : 240);
            }
        }
        if(updateDeckInfo){
            updateDeckInfo = 0;
            int startPos = 6;
            setwPrintf(4,startPos,255,0);
            wprintf(L"draws: %d",genList_getLength(player.drawDeck));
            positionwPrintf(4,startPos+1);
            wprintf(L"discards: %d",genList_getLength(player.discardDeck));
            positionwPrintf(4,startPos+2);
            wprintf(L"exhausts: %d",genList_getLength(player.exhaustDeck));
        }
        if(updateMuves){
            updateMuves = 0;
            setwPrintf(4,10,255,0);
            wprintf(L"muves: %d",player.muves);
        }
        if(redrawMainSection){
            redrawMainSection = 0;
            drawRect(CARDS_START_X,CARDS_START_Y,0,200,10);
            if(focus == 2){//show cards
                for(i = 0; i < HAND_SIZE; i++){
                    if(i == handCursor){
                        drawGuiSprite(CARDS_START_X+24*i-2,CARDS_START_Y-1,12);
                    }
                    drawCard(CARDS_START_X+24*i,CARDS_START_Y,hand[i]->data);
                }
                
            }
        }
        if(updateMainSection){
            updateMainSection = 0;
            if(lastHandCursor != -1){
                drawGuiSprite(CARDS_START_X+24*lastHandCursor-2,CARDS_START_Y-1,13);
                drawCard(CARDS_START_X+24*lastHandCursor,CARDS_START_Y,hand[lastHandCursor]->data);
                lastHandCursor = -1;
            }
            drawGuiSprite(CARDS_START_X+24*handCursor-2,CARDS_START_Y-1,12);
            drawCard(CARDS_START_X+24*handCursor,CARDS_START_Y,hand[handCursor]->data);
        }




        *ptrCommand = getch();
            if(*ptrCommand != COMMAND_QUIT){
                switch (*ptrCommand){
                    case 'w':
                    break;
                    case 's':
                    break;
                    case 'd':
                        if(focus == 2){
                            lastHandCursor = handCursor;
                            handCursor = (handCursor+1)%HAND_SIZE;
                            updateMainSection = 1;
                        }
                    break;
                    case 'a':
                        if(focus == 2){
                            lastHandCursor = handCursor;
                            handCursor = (handCursor+HAND_SIZE-1)%HAND_SIZE;
                            updateMainSection = 1;
                        }
                    break;
                    case ENTER_ASHII_CODE:
                    break;
                    case 'q':
                        //game->currGameState = STATE_NAVIGATION;
                        //game->flagChangeGameState = 1;
                    break;
                }
            }
    }while (*ptrCommand != COMMAND_QUIT && !game->flagChangeGameState);
    
}

void drawStartScreen(){
    system("cls");
    setwPrintfColor(15,0);
    drawGuiSprite(0,0,0);
    drawGuiSprite(7,4,1);

}



int main(){
    _setmode(_fileno(stdout), _O_U16TEXT);
    gameInstance_t game;
    //game.currGameState = STATE_INSTRUCTIONS_SCREEN;
    game.currGameState = STATE_CHARACTER_SELECTION;
    game.gameField = NULL;//all NULLS needed
    game.cardsPool = NULL;
    game.relicsPool = NULL;
    game.player.character = NULL;
    game.player.relics = NULL;
    game.player.drawDeck = NULL;
    game.player.discardDeck = NULL;
    game.player.exhaustDeck = NULL;
    game.player.potions = NULL;

    char command = '\0';

    wprintf(L"\e[?25l");//make cursor invisible


/*//test
    setwPrintfColor(2,2);
    system("cls");
    do{
    command = getch();
    setwPrintfColor(command,comman);
    system("cls");
    wprintf(L"dsfsdfsfe");
    }while (command != '0');
	
*/

    do{
        game.flagChangeGameState = 0;
        if(command != COMMAND_QUIT){

            if(game.currGameState == STATE_INSTRUCTIONS_SCREEN){
                int i;
                for(i = 0; i < 208; i++){
                    wprintf(L"-");
                }
	            wprintf(L"\n|maximise and press a key (press 0 at any point to quit)");
                for(i = 0; i < 55; i++){
                    wprintf(L"|\n");
                }
                command = getch();
                game.currGameState = STATE_START_SCREEN;
            }
            else if(game.currGameState == STATE_START_SCREEN){
                drawStartScreen();
                positionwPrintf(1,1);
                command = getch();
                game.currGameState = STATE_CHARACTER_SELECTION;
            }
            else if(game.currGameState == STATE_CHARACTER_SELECTION){
                routineCharacterSelection(&command, &game);

            }
            else if(game.currGameState == STATE_NAVIGATION){
                routineNavigation(&command, &game);

            }
            else if(game.currGameState == STATE_BATTLING){
                routineBattle(&command, &game);
            }
            else if(game.currGameState == STATE_SHOP){
                routineShop(&command, &game);
            }
            else if(game.currGameState == STATE_CHEST){
                routineChest(&command, &game);
            }
            else if(game.currGameState == STATE_ANVIL){
                routineAnvil(&command, &game);
            }else if(game.currGameState == STATE_REST_SITE){
                routineRestSite(&command, &game);
            }

        }
    }while (command != '0');
    
    wprintf(L"\e[39m\e[49m");
    system("cls");
    wprintf(L"thank you for playing!\n");
    wprintf(L"\e[?25h");//make cursor visible

    /*
    for(int i = 0; i <= 21; i++){
        setwPrintfColor(255,0);positionwPrintf(1,20*i+1);wprintf(L"%ls",createCard(i)->name);
        drawCardSprite(1,20*i+3,createCard(i)->spritesIds[0]);

    }*/

}









